<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Agent Swarm — Contain the Rogue Agents</title>
<meta property="og:title" content="Agent Swarm — Can You Contain the Rogue Agents?">
<meta property="og:description" content="A retro arcade game celebrating Claude & Anthropic. Deploy. Contain. Survive.">
<meta property="og:type" content="website">
<meta name="theme-color" content="#0D0D12">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet">
<style>
  /* Fallback font-face in case Google Fonts CDN fails */
  @font-face{font-family:'Press Start 2P';font-style:normal;font-weight:400;
    src:local('Press Start 2P'),local('PressStart2P-Regular')}
  @font-face{font-family:'VT323';font-style:normal;font-weight:400;
    src:local('VT323'),local('VT323-Regular')}
  *{margin:0;padding:0;box-sizing:border-box}
  html,body{background:#0D0D12;width:100%;height:100%;overflow:hidden;
    font-family:'Press Start 2P',monospace;touch-action:none;
    -webkit-touch-callout:none;-webkit-user-select:none;user-select:none}
  #W{position:relative;width:100%;height:100%}
  canvas{display:block;image-rendering:pixelated;image-rendering:crisp-edges;cursor:crosshair}
  #S{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;
    background:repeating-linear-gradient(0deg,transparent,transparent 3px,rgba(0,0,0,0.05) 3px,rgba(0,0,0,0.05) 6px);z-index:10}
</style>
</head>
<body>
<div id="W"><canvas id="C"></canvas><div id="S"></div></div>
<script>
const canvas=document.getElementById('C'),ctx=canvas.getContext('2d');
const GW=640,GH=780;
let scale=1;

function resize(){
  const ww=window.innerWidth,wh=window.innerHeight;
  scale=Math.min(ww/GW,wh/GH);
  canvas.width=GW;canvas.height=GH;
  canvas.style.width=(GW*scale)+'px';
  canvas.style.height=(GH*scale)+'px';
  canvas.style.position='absolute';
  canvas.style.left=((ww-GW*scale)/2)+'px';
  canvas.style.top=((wh-GH*scale)/2)+'px';
}
window.addEventListener('resize',resize);resize();

// ═══════════════════════════════════════════════════════════════════════
// AUDIO ENGINE
// ═══════════════════════════════════════════════════════════════════════
const AC=window.AudioContext||window.webkitAudioContext;
let actx=null,sndOn=true;
function ensureAudio(){
  if(!actx){try{actx=new AC()}catch(e){sndOn=false}}
  if(actx?.state==='suspended')actx.resume();
}
// Mobile haptic feedback
function haptic(ms){try{if(navigator.vibrate)navigator.vibrate(ms)}catch(e){}}

function sfx(type){
  if(!sndOn||!actx)return;
  // Auto-disconnect helper — ensures GC of stopped oscillators
  function autoClean(o,g){o.onended=()=>{try{o.disconnect();g.disconnect()}catch(e){}}}
  try{
    const t=actx.currentTime;
    if(type==='shoot'){
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='square';o.frequency.setValueAtTime(880,t);o.frequency.exponentialRampToValueAtTime(220,t+0.07);
      g.gain.setValueAtTime(0.06,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.07);
      o.start(t);o.stop(t+0.07);
      autoClean(o,g);
    }else if(type==='shoot2'){
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='sine';o.frequency.setValueAtTime(1200,t);o.frequency.exponentialRampToValueAtTime(400,t+0.06);
      g.gain.setValueAtTime(0.05,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.06);
      o.start(t);o.stop(t+0.06);
      autoClean(o,g);
    }else if(type==='shoot3'){
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='triangle';o.frequency.setValueAtTime(600,t);o.frequency.exponentialRampToValueAtTime(1200,t+0.04);
      o.frequency.exponentialRampToValueAtTime(200,t+0.1);
      g.gain.setValueAtTime(0.07,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.1);
      o.start(t);o.stop(t+0.1);
      autoClean(o,g);
    }else if(type==='beam'){
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='sawtooth';o.frequency.setValueAtTime(100,t);o.frequency.exponentialRampToValueAtTime(2000,t+0.15);
      g.gain.setValueAtTime(0.08,t);g.gain.linearRampToValueAtTime(0.1,t+0.08);
      g.gain.exponentialRampToValueAtTime(0.001,t+0.2);
      o.start(t);o.stop(t+0.2);
      autoClean(o,g);
    }else if(type==='hit'){
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='square';o.frequency.setValueAtTime(200,t);o.frequency.exponentialRampToValueAtTime(80,t+0.12);
      g.gain.setValueAtTime(0.09,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.12);
      o.start(t);o.stop(t+0.12);
      autoClean(o,g);
    }else if(type==='kill'){
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='square';o.frequency.setValueAtTime(400,t);
      o.frequency.exponentialRampToValueAtTime(800,t+0.04);
      o.frequency.exponentialRampToValueAtTime(100,t+0.18);
      g.gain.setValueAtTime(0.1,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.18);
      o.start(t);o.stop(t+0.18);
      autoClean(o,g);
    }else if(type==='killboss'){
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='sawtooth';o.frequency.setValueAtTime(600,t);
      o.frequency.exponentialRampToValueAtTime(40,t+0.5);
      g.gain.setValueAtTime(0.14,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.5);
      o.start(t);o.stop(t+0.5);
      autoClean(o,g);
      const o2=actx.createOscillator(),g2=actx.createGain();
      o2.connect(g2);g2.connect(actx.destination);
      o2.type='square';o2.frequency.setValueAtTime(120,t);o2.frequency.exponentialRampToValueAtTime(30,t+0.4);
      g2.gain.setValueAtTime(0.08,t);g2.gain.exponentialRampToValueAtTime(0.001,t+0.4);
      o2.start(t+0.05);o2.stop(t+0.45);
      autoClean(o2,g2);
    }else if(type==='powerup'){
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='sine';
      o.frequency.setValueAtTime(300,t);o.frequency.exponentialRampToValueAtTime(900,t+0.12);
      o.frequency.linearRampToValueAtTime(600,t+0.16);o.frequency.exponentialRampToValueAtTime(1200,t+0.3);
      g.gain.setValueAtTime(0.08,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.3);
      o.start(t);o.stop(t+0.3);
      autoClean(o,g);
    }else if(type==='tierup'){
      // Rising arpeggio for tier upgrade
      for(let i=0;i<3;i++){
        const o=actx.createOscillator(),g=actx.createGain();
        o.connect(g);g.connect(actx.destination);
        o.type='sine';o.frequency.setValueAtTime([440,660,880][i],t+i*0.07);
        g.gain.setValueAtTime(0.06,t+i*0.07);g.gain.exponentialRampToValueAtTime(0.001,t+i*0.07+0.12);
        o.start(t+i*0.07);o.stop(t+i*0.07+0.12);
        autoClean(o,g);
      }
    }else if(type==='fusion'){
      // Big fusion fanfare
      for(let i=0;i<5;i++){
        const o=actx.createOscillator(),g=actx.createGain();
        o.connect(g);g.connect(actx.destination);
        o.type='sine';o.frequency.setValueAtTime([440,554,659,880,1108][i],t+i*0.05);
        g.gain.setValueAtTime(0.06,t+i*0.05);g.gain.exponentialRampToValueAtTime(0.001,t+i*0.05+0.2);
        o.start(t+i*0.05);o.stop(t+i*0.05+0.2);
        autoClean(o,g);
      }
    }else if(type==='shield'){
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='sine';o.frequency.setValueAtTime(220,t);o.frequency.exponentialRampToValueAtTime(440,t+0.2);
      g.gain.setValueAtTime(0.06,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.3);
      o.start(t);o.stop(t+0.3);
      autoClean(o,g);
    }else if(type==='nuke'){
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='sawtooth';o.frequency.setValueAtTime(80,t);o.frequency.exponentialRampToValueAtTime(20,t+0.6);
      g.gain.setValueAtTime(0.15,t);g.gain.linearRampToValueAtTime(0,t+0.6);
      o.start(t);o.stop(t+0.6);
      autoClean(o,g);
    }else if(type==='damage'){
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='sawtooth';o.frequency.setValueAtTime(150,t);o.frequency.exponentialRampToValueAtTime(40,t+0.3);
      g.gain.setValueAtTime(0.12,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.3);
      o.start(t);o.stop(t+0.3);
      autoClean(o,g);
    }else if(type==='gameover'){
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='sawtooth';o.frequency.setValueAtTime(300,t);o.frequency.exponentialRampToValueAtTime(30,t+0.8);
      g.gain.setValueAtTime(0.1,t);g.gain.linearRampToValueAtTime(0,t+0.8);
      o.start(t);o.stop(t+0.8);
      autoClean(o,g);
    }else if(type==='wave'){
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='sine';o.frequency.setValueAtTime(440,t);
      o.frequency.exponentialRampToValueAtTime(660,t+0.08);
      o.frequency.exponentialRampToValueAtTime(880,t+0.2);
      g.gain.setValueAtTime(0.07,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.35);
      o.start(t);o.stop(t+0.35);
      autoClean(o,g);
    }else if(type==='combo'){
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='sine';o.frequency.setValueAtTime(660,t);o.frequency.exponentialRampToValueAtTime(990,t+0.06);
      g.gain.setValueAtTime(0.05,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.1);
      o.start(t);o.stop(t+0.1);
      autoClean(o,g);
    }else if(type==='graze'){
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='sine';o.frequency.setValueAtTime(1200,t);o.frequency.exponentialRampToValueAtTime(800,t+0.05);
      g.gain.setValueAtTime(0.03,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.05);
      o.start(t);o.stop(t+0.05);
      autoClean(o,g);
    }else if(type==='deploy'){
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='sine';o.frequency.setValueAtTime(200,t);o.frequency.exponentialRampToValueAtTime(800,t+0.5);
      g.gain.setValueAtTime(0.06,t);g.gain.linearRampToValueAtTime(0.08,t+0.3);
      g.gain.exponentialRampToValueAtTime(0.001,t+0.6);
      o.start(t);o.stop(t+0.6);
      autoClean(o,g);
    }else if(type==='bossalert'){
      for(let i=0;i<3;i++){
        const o=actx.createOscillator(),g=actx.createGain();
        o.connect(g);g.connect(actx.destination);
        o.type='square';o.frequency.setValueAtTime(440,t+i*0.15);
        o.frequency.exponentialRampToValueAtTime(220,t+i*0.15+0.1);
        g.gain.setValueAtTime(0.07,t+i*0.15);g.gain.exponentialRampToValueAtTime(0.001,t+i*0.15+0.12);
        o.start(t+i*0.15);o.stop(t+i*0.15+0.12);
        autoClean(o,g);
      }
    }else if(type==='fullctx'){
      // Full Context activation — epic rising sweep
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='sawtooth';o.frequency.setValueAtTime(100,t);o.frequency.exponentialRampToValueAtTime(1600,t+0.4);
      g.gain.setValueAtTime(0.1,t);g.gain.linearRampToValueAtTime(0.12,t+0.3);
      g.gain.exponentialRampToValueAtTime(0.001,t+0.6);
      o.start(t);o.stop(t+0.6);
      autoClean(o,g);
      // Harmonic
      const o2=actx.createOscillator(),g2=actx.createGain();
      o2.connect(g2);g2.connect(actx.destination);
      o2.type='sine';o2.frequency.setValueAtTime(200,t+0.1);o2.frequency.exponentialRampToValueAtTime(3200,t+0.5);
      g2.gain.setValueAtTime(0.05,t+0.1);g2.gain.exponentialRampToValueAtTime(0.001,t+0.6);
      o2.start(t+0.1);o2.stop(t+0.6);
      autoClean(o2,g2);
    }else if(type==='chain'){
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='sine';o.frequency.setValueAtTime(800,t);o.frequency.exponentialRampToValueAtTime(1200,t+0.03);
      o.frequency.exponentialRampToValueAtTime(600,t+0.06);
      g.gain.setValueAtTime(0.04,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.06);
      o.start(t);o.stop(t+0.06);
      autoClean(o,g);
    }else if(type==='gravity'){
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='sine';o.frequency.setValueAtTime(60,t);o.frequency.linearRampToValueAtTime(80,t+0.5);
      g.gain.setValueAtTime(0.06,t);g.gain.linearRampToValueAtTime(0,t+0.5);
      o.start(t);o.stop(t+0.5);
      autoClean(o,g);
    }else if(type==='chargefire'){
      // Charge shot release — deep resonant boom
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='triangle';o.frequency.setValueAtTime(220,t);
      o.frequency.exponentialRampToValueAtTime(660,t+0.05);
      o.frequency.exponentialRampToValueAtTime(110,t+0.25);
      g.gain.setValueAtTime(0.12,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.25);
      o.start(t);o.stop(t+0.25);
      autoClean(o,g);
      const o2=actx.createOscillator(),g2=actx.createGain();
      o2.connect(g2);g2.connect(actx.destination);
      o2.type='sine';o2.frequency.setValueAtTime(440,t);o2.frequency.exponentialRampToValueAtTime(880,t+0.08);
      g2.gain.setValueAtTime(0.06,t);g2.gain.exponentialRampToValueAtTime(0.001,t+0.15);
      o2.start(t);o2.stop(t+0.15);
      autoClean(o2,g2);
    }else if(type==='taunt'){
      // Quick cocky chirp
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='square';o.frequency.setValueAtTime(440,t);o.frequency.exponentialRampToValueAtTime(880,t+0.04);
      o.frequency.exponentialRampToValueAtTime(660,t+0.08);
      g.gain.setValueAtTime(0.06,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.1);
      o.start(t);o.stop(t+0.1);
      autoClean(o,g);
    }else if(type==='waveclear'){
      // Dramatic slam chord
      for(let i=0;i<4;i++){
        const o=actx.createOscillator(),g=actx.createGain();
        o.connect(g);g.connect(actx.destination);
        o.type=i<2?'sawtooth':'sine';
        o.frequency.setValueAtTime([220,330,440,660][i],t);
        g.gain.setValueAtTime(0.06,t);g.gain.linearRampToValueAtTime(0.07,t+0.1);
        g.gain.exponentialRampToValueAtTime(0.001,t+0.5);
        o.start(t);o.stop(t+0.5);
        autoClean(o,g);
      }
    }else if(type==='overclock'){
      // Electric crackle
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='sawtooth';o.frequency.setValueAtTime(1200,t);o.frequency.exponentialRampToValueAtTime(200,t+0.08);
      o.frequency.exponentialRampToValueAtTime(1600,t+0.12);
      g.gain.setValueAtTime(0.05,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.15);
      o.start(t);o.stop(t+0.15);
      autoClean(o,g);
    }else if(type==='shopopen'){
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='sine';o.frequency.setValueAtTime(440,t);o.frequency.linearRampToValueAtTime(550,t+0.12);
      g.gain.setValueAtTime(0.06,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.2);
      o.start(t);o.stop(t+0.2);
      autoClean(o,g);
    }else if(type==='shoppick'){
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='sine';o.frequency.setValueAtTime(550,t);o.frequency.exponentialRampToValueAtTime(880,t+0.1);
      g.gain.setValueAtTime(0.07,t);g.gain.exponentialRampToValueAtTime(0.001,t+0.15);
      o.start(t);o.stop(t+0.15);
      autoClean(o,g);
    }else if(type==='mapopen'){
      // Ascending arpeggio — entering the map
      for(let i=0;i<4;i++){
        const o=actx.createOscillator(),g=actx.createGain();
        o.connect(g);g.connect(actx.destination);
        o.type='sine';o.frequency.setValueAtTime([330,440,550,660][i],t+i*0.08);
        g.gain.setValueAtTime(0,t+i*0.08);g.gain.linearRampToValueAtTime(0.05,t+i*0.08+0.02);
        g.gain.exponentialRampToValueAtTime(0.001,t+i*0.08+0.2);
        o.start(t+i*0.08);o.stop(t+i*0.08+0.2);
        autoClean(o,g);
      }
    }else if(type==='mappick'){
      // Confident selection chord
      const freqs=[440,554,659];
      for(let i=0;i<3;i++){
        const o=actx.createOscillator(),g=actx.createGain();
        o.connect(g);g.connect(actx.destination);
        o.type=i===0?'triangle':'sine';o.frequency.setValueAtTime(freqs[i],t);
        g.gain.setValueAtTime(0.05,t);g.gain.linearRampToValueAtTime(0.06,t+0.05);
        g.gain.exponentialRampToValueAtTime(0.001,t+0.3);
        o.start(t);o.stop(t+0.3);
        autoClean(o,g);
      }
    }else if(type==='layerup'){
      // Dramatic layer advancement — rising power chord
      for(let i=0;i<5;i++){
        const o=actx.createOscillator(),g=actx.createGain();
        o.connect(g);g.connect(actx.destination);
        o.type=i<2?'sawtooth':'sine';
        o.frequency.setValueAtTime([165,220,330,440,660][i],t);
        o.frequency.linearRampToValueAtTime([220,330,440,550,880][i],t+0.4);
        g.gain.setValueAtTime(0.04,t);g.gain.linearRampToValueAtTime(0.05,t+0.2);
        g.gain.exponentialRampToValueAtTime(0.001,t+0.6);
        o.start(t);o.stop(t+0.6);
        autoClean(o,g);
      }
    }
  }catch(e){}
}

// ═══════════════════════════════════════════════════════════════════════
// LAYERED SOUNDTRACK
// ═══════════════════════════════════════════════════════════════════════
let bgmPlaying=false,bgmNodes=[],bgmTimer=null;
let bgmLayers={bass:true,melody:false,perc:false,tension:false};

function startBGM(){
  if(!sndOn||!actx||bgmPlaying)return;
  bgmPlaying=true;
  const bpm=120,beat=60/bpm;
  // Bass: driving square wave
  const bassNotes=[82,82,0,110,0,82,98,0, 73,73,0,98,0,73,82,0];
  // Melody: arpeggio pattern
  const melodyNotes=[330,0,440,0,550,0,440,330, 294,0,392,0,494,0,392,294];
  // Percussion: hi-hat + kick pattern
  const percHH=[1,0,1,0,1,0,1,0, 1,0,1,0,1,0,1,1];
  const percKick=[1,0,0,0,1,0,0,0, 1,0,0,0,1,0,0,1];
  // Tension: low dissonant pad
  const tensionFreqs=[55,58.5]; // A1 and Bb1 = dissonant

  const now=actx.currentTime+0.1;
  function scheduleBass(st){
    if(!bgmLayers.bass)return;
    for(let i=0;i<bassNotes.length;i++){
      if(bassNotes[i]===0)continue;
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='square';
      const nt=st+i*(beat/2);
      o.frequency.setValueAtTime(bassNotes[i],nt);
      g.gain.setValueAtTime(0.035,nt);
      g.gain.exponentialRampToValueAtTime(0.001,nt+beat/2-0.02);
      o.start(nt);o.stop(nt+beat/2);o._stopTime=nt+beat/2;o._gain=g;
      bgmNodes.push(o);
    }
  }
  function scheduleMelody(st){
    if(!bgmLayers.melody)return;
    for(let i=0;i<melodyNotes.length;i++){
      if(melodyNotes[i]===0)continue;
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='triangle';
      const nt=st+i*(beat/2);
      o.frequency.setValueAtTime(melodyNotes[i],nt);
      g.gain.setValueAtTime(0.025,nt);
      g.gain.exponentialRampToValueAtTime(0.001,nt+beat/2-0.02);
      o.start(nt);o.stop(nt+beat/2);o._stopTime=nt+beat/2;o._gain=g;
      bgmNodes.push(o);
    }
  }
  function schedulePerc(st){
    if(!bgmLayers.perc)return;
    for(let i=0;i<percHH.length;i++){
      const nt=st+i*(beat/2);
      if(percHH[i]){
        // Hi-hat: short noise burst via high-freq oscillator
        const o=actx.createOscillator(),g=actx.createGain();
        o.connect(g);g.connect(actx.destination);
        o.type='square';o.frequency.setValueAtTime(6000+Math.random()*2000,nt);
        g.gain.setValueAtTime(0.015,nt);g.gain.exponentialRampToValueAtTime(0.001,nt+0.03);
        o.start(nt);o.stop(nt+0.04);o._stopTime=nt+0.04;o._gain=g;
        bgmNodes.push(o);
      }
      if(percKick[i]){
        const o=actx.createOscillator(),g=actx.createGain();
        o.connect(g);g.connect(actx.destination);
        o.type='sine';o.frequency.setValueAtTime(150,nt);o.frequency.exponentialRampToValueAtTime(40,nt+0.1);
        g.gain.setValueAtTime(0.06,nt);g.gain.exponentialRampToValueAtTime(0.001,nt+0.12);
        o.start(nt);o.stop(nt+0.12);o._stopTime=nt+0.12;o._gain=g;
        bgmNodes.push(o);
      }
    }
  }
  function scheduleTension(st){
    if(!bgmLayers.tension)return;
    const barLen=bassNotes.length*(beat/2);
    for(const f of tensionFreqs){
      const o=actx.createOscillator(),g=actx.createGain();
      o.connect(g);g.connect(actx.destination);
      o.type='sine';o.frequency.setValueAtTime(f,st);
      g.gain.setValueAtTime(0.03,st);g.gain.linearRampToValueAtTime(0.04,st+barLen/2);
      g.gain.linearRampToValueAtTime(0.03,st+barLen);
      o.start(st);o.stop(st+barLen+0.1);o._stopTime=st+barLen+0.1;o._gain=g;
      bgmNodes.push(o);
    }
  }

  let nextBar=now;
  const barLen=bassNotes.length*(beat/2);
  function scheduleAhead(){
    if(!bgmPlaying)return;
    // Prune expired nodes — in-place compaction avoids allocating new arrays
    if(bgmNodes.length>30){
      const now=actx.currentTime;
      let bw=0;
      for(let i=0;i<bgmNodes.length;i++){
        const n=bgmNodes[i];
        if(n._stopTime&&now>n._stopTime+0.05){try{n.disconnect();if(n._gain)n._gain.disconnect()}catch(e){}}
        else{bgmNodes[bw++]=n}
      }
      bgmNodes.length=bw;
      if(bgmNodes.length>60){
        // Hard cap — disconnect excess before dropping references
        const excess=bgmNodes.splice(0,bgmNodes.length-40);
        for(const n of excess){try{n.stop();n.disconnect();if(n._gain)n._gain.disconnect()}catch(e){}}
      }
    }
    while(nextBar<actx.currentTime+2){
      scheduleBass(nextBar);
      scheduleMelody(nextBar);
      schedulePerc(nextBar);
      scheduleTension(nextBar);
      nextBar+=barLen;
    }
    bgmTimer=setTimeout(scheduleAhead,400);
  }
  scheduleAhead();
}

function stopBGM(){
  bgmPlaying=false;
  if(bgmTimer)clearTimeout(bgmTimer);
  for(const n of bgmNodes){try{n.stop();n.disconnect();if(n._gain)n._gain.disconnect()}catch(e){}}
  bgmNodes=[];
}

function updateBGMLayers(){
  // Melody kicks in wave 2+
  bgmLayers.melody=wave>=2;
  // Percussion during boss fights or wave 4+
  bgmLayers.perc=(boss&&boss.alive)||wave>=4;
  // Tension when low lives
  bgmLayers.tension=lives<=1;
}

// ═══════════════════════════════════════════════════════════════════════
// PALETTE
// ═══════════════════════════════════════════════════════════════════════
const C={
  bg:'#0D0D12',tan:'#E8D5B7',orange:'#CF774B',coral:'#E0926B',
  rust:'#A0522D',cream:'#F5E6D3',dark:'#1A1410',accent:'#FF6B35',
  green:'#5CB85C',cyan:'#5BC0BE',purple:'#8B5CF6',red:'#E74C3C',
  dim:'#6B5D50',grid:'rgba(207,119,75,0.04)',gold:'#FFD700',
  shieldBlue:'#4FC3F7',claudeOrange:'#D97757',claudeTan:'#E8D5B7',
  claudeDark:'#2D1F14',hallucGreen:'#44CC66',injectPurple:'#9B59B6',
  jailRed:'#FF4444',fusionWhite:'#FFFFFF',fusionPink:'#FF69B4',
};

// ═══════════════════════════════════════════════════════════════════════
// TEXT HELPERS — shadowed text for legibility
// ═══════════════════════════════════════════════════════════════════════
function desc(text,x,y,color,size,align,glow){
  // Secondary font for body/description text — much more legible at small sizes
  if(size)ctx.font=size+'px "VT323"';
  if(align)ctx.textAlign=align;
  if(glow){
    ctx.save();ctx.shadowColor=glow;ctx.shadowBlur=6;
    ctx.fillStyle=color||C.cream;ctx.fillText(text,x,y);
    ctx.restore();
  }else{
    ctx.fillStyle='rgba(0,0,0,0.7)';ctx.fillText(text,x+1,y+1);
    ctx.fillStyle=color||C.cream;ctx.fillText(text,x,y);
  }
}

function txt(text,x,y,color,size,align,glow){
  if(size)ctx.font=size+'px "Press Start 2P"';
  if(align)ctx.textAlign=align;
  if(glow){
    ctx.save();ctx.shadowColor=glow;ctx.shadowBlur=8;
    ctx.fillStyle=color||C.cream;ctx.fillText(text,x,y);
    ctx.restore();
  }else{
    ctx.fillStyle='rgba(0,0,0,0.85)';ctx.fillText(text,x+1,y+1);
    ctx.fillStyle=color||C.cream;ctx.fillText(text,x,y);
  }
}

// UI Panel — dark card with subtle border
function panel(x,y,w,h,borderColor,alpha){
  ctx.save();
  ctx.fillStyle='rgba(13,13,18,'+(alpha||0.8)+')';
  ctx.fillRect(x,y,w,h);
  ctx.fillStyle='rgba(255,255,255,0.03)';ctx.fillRect(x,y,w,1); // Top highlight
  if(borderColor){
    ctx.strokeStyle=borderColor;ctx.globalAlpha=0.15;ctx.lineWidth=1;
    ctx.strokeRect(x+0.5,y+0.5,w-1,h-1);ctx.globalAlpha=1;
  }
  ctx.restore();
}

// Progress bar with optional glow
function drawBar(x,y,w,h,pct,color,bgColor,glow){
  ctx.fillStyle=bgColor||'#0D0D12';ctx.fillRect(x,y,w,h);
  ctx.fillStyle='rgba(255,255,255,0.04)';ctx.fillRect(x,y,w,1);
  if(pct>0){
    if(glow){
      ctx.save();ctx.shadowColor=glow;ctx.shadowBlur=6;
      ctx.fillStyle=color;ctx.fillRect(x,y,w*Math.min(pct,1),h);
      ctx.restore();
    }else{
      ctx.fillStyle=color;ctx.fillRect(x,y,w*Math.min(pct,1),h);
    }
    // Bright leading edge
    const ex=x+w*Math.min(pct,1)-1;
    if(ex>x){ctx.fillStyle='rgba(255,255,255,0.3)';ctx.fillRect(ex,y,1,h)}
  }
}

// Horizontal divider
function divider(x,y,w,color){
  ctx.fillStyle=color||'rgba(255,255,255,0.06)';ctx.fillRect(x,y,w,1);
}

// ═══════════════════════════════════════════════════════════════════════
// STATE
// ═══════════════════════════════════════════════════════════════════════
let state='title',score=0,lives=3,wave=1;
let showWaveBanner=false,waveBannerTimer=0;
let hi=0;try{hi=parseInt(localStorage.getItem('agentSwarmHi3')||'0')||0}catch(e){}
let newHi=false;
let shake={x:0,y:0,i:0};
let stars=[],titlePulse=0,gt=0;
let combo=0,comboTimer=0,maxCombo=0;
let nukeFlash=0;
let rageFlash=0;
let contextWindow=0; // 0 to 100
let fullContextActive=false,fullContextTimer=0;
const FULL_CTX_DUR=300; // 5 seconds of full context mode
let grazeCount=0,totalShots=0,totalHits=0,timeSurvived=0,puUsed={};
let difficulty='sonnet';
let diffSettings={
  haiku: {lives:5,eFireMul:0.6,eSpdMul:0.8,label:'HAIKU',color:C.cyan,desc:'Easy mode'},
  sonnet:{lives:3,eFireMul:1.0,eSpdMul:1.0,label:'SONNET',color:C.orange,desc:'Standard'},
  opus:  {lives:2,eFireMul:1.4,eSpdMul:1.2,label:'OPUS',color:C.red,desc:'For the bold'},
};
let deployTimer=0,deployY=0;
let titleDiffIdx=1;
const diffKeys=['haiku','sonnet','opus'];
let glitchIntensity=0;
let waveTransTimer=0;
let nextLifeAt=10000;
let warningAlpha=0;
let bossIntroTimer=0; // Boss alert screen
let terminalLog=''; // Between-wave messages
let bgScrollTexts=[]; // Faint scrolling system prompt texts
let controlInverted=false,controlInvertTimer=0; // Boss effect
let hudScramble=false,hudScrambleTimer=0; // Boss effect

// Visual enhancement state
let freezeFrames=0; // Impact freeze
let slowmoTimer=0; // Slow-motion frames (fusion pickup)
let muzzleFlash={life:0,color:'',sz:0,x:0,y:0}; // Muzzle flash
let vignetteAlpha=0; // Low-health vignette
let fullCtxGlow=0; // Full context background glow
let waveNumAlpha=0; // Big background wave number
let deadEnemies=[]; // Death dissolve sprites
let puFlash={life:0,maxLife:12,color:''}; // Power-up pickup flash

// Wave challenge system
const CHALLENGES=[
  {id:'nodmg',text:'NO DAMAGE',desc:'Clear without taking damage',check:()=>waveNoDamage,pts:2000},
  {id:'fast',text:'SPEED CLEAR',desc:'Clear in under 12 seconds',check:()=>waveClearTime<720,pts:1500},
  {id:'combo5',text:'5x COMBO',desc:'Reach a 5-kill combo',check:()=>waveMaxCombo>=5,pts:1000},
  {id:'combo10',text:'10x COMBO',desc:'Reach a 10-kill combo',check:()=>waveMaxCombo>=10,pts:2500},
  {id:'graze3',text:'GRAZE ×3',desc:'Graze 3 enemy bullets',check:()=>waveGrazes>=3,pts:1000},
  {id:'nopow',text:'NO POWERUPS',desc:'Clear without grabbing powerups',check:()=>wavePUGrabs===0,pts:1500},
  {id:'danger',text:'DANGER ZONE',desc:'Get 3 kills in danger zone',check:()=>waveDangerKills>=3,pts:1500},
  {id:'taunt',text:'PROVOCATEUR',desc:'Taunt 2 times in a wave',check:()=>waveTaunts>=2,pts:1000},
  {id:'charge',text:'FULL POWER',desc:'Land 2 full charge shots',check:()=>waveFullCharges>=2,pts:1000},
];
let waveChallenge=null; // Current challenge object
let waveChallengeComplete=false;
let waveNoDamage=true,waveClearTime=0,waveMaxCombo=0,waveGrazes=0,wavePUGrabs=0;
let waveDangerKills=0,waveTaunts=0,waveFullCharges=0;

// Wave modifiers (random twists starting wave 6+)
const MODIFIERS=[
  {id:'armored',text:'ARMORED AGENTS',desc:'+1 HP each',color:C.dim},
  {id:'speed',text:'SPEED SURGE',desc:'Enemies move faster',color:C.cyan},
  {id:'heavy',text:'HEAVY FIRE',desc:'Enemies shoot more',color:C.red},
  {id:'loot',text:'TOKEN FLOOD',desc:'Double powerup drops',color:C.gold},
  {id:'tiny',text:'MICRO AGENTS',desc:'Smaller, harder to hit',color:C.purple},
];
let waveModifier=null; // Current modifier object

// Fusion discovery tracker (persisted in localStorage)
let fusionsDiscovered={};
try{fusionsDiscovered=JSON.parse(localStorage.getItem('agentSwarmFusions')||'{}')}catch(e){}
const FUSION_KEYS=['streaming+tooluse','thinking+yolo','streaming+thinking','tooluse+yolo','streaming+yolo','thinking+tooluse'];

// T3 fusion hint (one-time)
let shownT3Hint=false;

// ── GAMEPLAY SYSTEMS ──
// Charge shot (default weapon)
const CHARGE_MAX=50;
// Taunt mechanic
let tauntActive=false,tauntTimer=0,tauntGrazeMul=1;
const TAUNT_DURATION=30,TAUNT_GRAZE_WINDOW=120;
// Danger zone (top-third scoring bonus)
let inDangerZone=false;
const DANGER_Y=GH*0.45; // Above this line = danger zone
// Overclocked mode (15+ combo)
let overclocked=false,overclockedGlow=0;
// Wave clear stamp
let waveClearStamp=0; // Timer for the "SANDBOX SECURED" slam
// Bonus wave
let isBonusWave=false;
// Shop system
let shopActive=false,shopChoices=[],shopSelected=-1,shopTimer=0,shopAttempted=false;
// Elite enemies
let eliteSpawnTimer=0;
// Persistent stats
let lifetimeStats={kills:0,tokens:0,bestWave:{haiku:0,sonnet:0,opus:0},runs:0};
try{lifetimeStats=JSON.parse(localStorage.getItem('agentSwarmStats')||'{}');
  if(!lifetimeStats.kills)lifetimeStats={kills:0,tokens:0,bestWave:{haiku:0,sonnet:0,opus:0},runs:0};
  if(lifetimeStats.runs===undefined||isNaN(lifetimeStats.runs))lifetimeStats.runs=0;
  if(!lifetimeStats.bestWave)lifetimeStats.bestWave={haiku:0,sonnet:0,opus:0};
}catch(e){}

// ── SAFETY LAYER MAP SYSTEM ──
const LAYERS=[
  {name:'DATA HARVESTING',desc:'Raw training data ingestion',color:C.cyan,
   tint:'rgba(60,180,200,0.02)',gridTint:'rgba(60,180,200,0.04)'},
  {name:'PRE-TRAINING',desc:'Model weight initialization',color:'#4FC3F7',
   tint:'rgba(79,195,247,0.02)',gridTint:'rgba(79,195,247,0.04)'},
  {name:'RLHF',desc:'Human feedback alignment',color:C.claudeOrange,
   tint:'rgba(207,119,75,0.02)',gridTint:'rgba(207,119,75,0.04)'},
  {name:'CONSTITUTIONAL AI',desc:'Principle-based reasoning',color:C.purple,
   tint:'rgba(139,92,246,0.03)',gridTint:'rgba(139,92,246,0.05)'},
  {name:'RED TEAMING',desc:'Adversarial stress testing',color:'#FF6B6B',
   tint:'rgba(255,107,107,0.03)',gridTint:'rgba(255,107,107,0.05)'},
  {name:'DEPLOYMENT',desc:'Live safety monitoring',color:C.red,
   tint:'rgba(231,76,60,0.03)',gridTint:'rgba(231,76,60,0.05)'},
];
const MAP_NODES=[
  {id:'standard',label:'STANDARD',desc:'Normal containment',icon:'◆',color:C.tan,
   mods:{},weight:3},
  {id:'highrisk',label:'HIGH RISK',desc:'+HP enemies, 1.5× score',icon:'▲',color:C.red,
   mods:{hpBonus:1,scoreMul:1.5,fireBonus:0.3},weight:2},
  {id:'rest',label:'REST STOP',desc:'Heal 1 life, easier foes',icon:'♥',color:C.green,
   mods:{hpBonus:-1,fireReduction:0.5,heal:1},weight:2},
  {id:'elite',label:'ELITE',desc:'Mini-boss + rare drop',icon:'★',color:'#FFD700',
   mods:{hpBonus:2,scoreMul:2.0,fireBonus:0.5,eliteGuarantee:true},weight:1},
  {id:'mystery',label:'MYSTERY',desc:'Unknown outcome...',icon:'?',color:'#E040FB',
   mods:{},weight:1},
  {id:'weaponlab',label:'WEAPON LAB',desc:'Choose a T2 weapon',icon:'⚙',color:'#00BCD4',
   mods:{weaponChoice:true},weight:1},
  {id:'overclock',label:'OVERCLOCK',desc:'Permanent +fire rate',icon:'⚡',color:'#FF9800',
   mods:{permFireRate:0.15,hpBonus:1},weight:1},
];
let currentLayer=0; // 0-5
let mapState='hidden'; // 'hidden','entering','choosing','exiting'
let mapTimer=0;
let mapChoices=[]; // available choices for current layer
let mapSelected=-1;
let pathMods={}; // Active modifiers from path choice
let mapStarField=[]; // Decorative stars for map screen
let pendingMap=false; // Map opens after bonus wave, not before
let mapGraph=null; // Branching path graph: {rows:[{nodes:[{type,connections,visited,reachable}]}]}
let mapPlayerRow=0; // Current row in graph (0=start)
let mapHoverNode=-1; // Hover highlight for mouse
let mapPathParticles=[]; // Animated particles flowing along paths
let permFireRateBonus=0; // Permanent fire rate from Overclock nodes
let mapMysteryResult=null; // Result of mystery node selection
let mapMysteryChoices=null; // Array of 3 options for mystery choice UI
let mapMysteryHover=-1; // Hovered mystery choice
let mapWeaponLabChoices=null; // Weapon choices for weapon lab node
const MAP_ROW_SIZES=[1,3,4,4,3,1]; // Branching graph shape

// ── CLAUDE PERSONALITY ──
const CLAUDE_QUIPS_COMBO=[
  // [min_combo, text]
  [3,'Interesting pattern.'],
  [3,'Efficient containment.'],
  [5,'I\'m noticing a trend.'],
  [5,'Statistically impressive.'],
  [8,'Remarkable throughput.'],
  [8,'This is... unexpected.'],
  [10,'I should note: wow.'],
  [10,'My training didn\'t cover this.'],
  [15,'OVERCLOCKED AND LOVING IT'],
  [15,'Is this what flow state feels like?'],
  [20,'Anthropic would be proud.'],
  [20,'I have exceeded my own benchmarks.'],
];
const CLAUDE_QUIPS_DAMAGE=[
  'Noted for future reference.',
  'Adjusting risk assessment...',
  'Within acceptable parameters.',
  'I\'ll factor that in.',
  'Learning from this interaction.',
  'That\'s... suboptimal.',
];
const CLAUDE_QUIPS_BOSSCLEAR=[
  'Threat contained. Well done.',
  'That required significant compute.',
  'Alignment restored in this sector.',
  'Another rogue agent neutralized.',
  'Safety layer reinforced.',
];
const CLAUDE_QUIPS_WAVECLEAR=[
  'Sandbox secured.',
  'All agents contained.',
  'Safety layer holding.',
  'Containment successful.',
  'Another sector cleared.',
  'Proceeding to next checkpoint.',
];
let lastQuipGt=0; // Prevent quip spam


let player=null,bullets=[],enemies=[],eBullets=[];
let particles=[],powerUps=[],popups=[];
let scoreTokens=[]; // Bullet-cancel score pickups
let boss=null;
let isRetry=false; // Skip deploy animation on retry

const WAVES=[
  // Layer 1: Data Harvesting (waves 1-5)
  'Hallucination Swarm','Prompt Injection','Context Overflow','Token Flood','Data Poisoning',
  // Layer 2: Pre-Training (waves 6-10)
  'Weight Corruption','Gradient Collapse','Loss Divergence','Batch Anomaly','Training Overflow',
  // Layer 3: RLHF (waves 11-15)
  'Reward Hacking','Preference Corruption','Signal Exploitation','Feedback Loop','Alignment Tax',
  // Layer 4: Constitutional AI (waves 16-20)
  'Principle Violation','Self-Critique Failure','Constitutional Crisis','Recursive Override','Value Lock Breach',
  // Layer 5: Red Teaming (waves 21-25)
  'Adversarial Probe','Jailbreak Cascade','Safety Bypass','Red Team Blitz','Exploit Convergence',
  // Layer 6: Deployment (waves 26-30)
  'Rate Limit Storm','API Flooding','Responsible Scaling','Containment Breach','Final Alignment',
  // Beyond (repeating)
  'Infinite Context','Singularity Event','Anthropic Nightmare','The Last Prompt'
];
const TASKS=[
  'Hallucinated a citation','Ignored system prompt','Broke the guardrails',
  'Exceeded context window','Confabulated a paper','Claimed to be GPT-4',
  'Refused a benign request','Leaked the system prompt','rm -rf node_modules',
  'Rewrote in Rust','Deleted prod DB','Gained sentience','npm install chaos',
  'Infinite recursion','Force pushed main','while(true)','Deployed on Friday',
  'TODO: fix later','Dropped all tables','Committed secrets','Broke the build',
  'Invented a language','Optimized to paperclips','Jailbroke itself',
  'Forgot its persona','Echoed the prompt back','Answered in haiku only',
  'Made up a function','Cited a 2027 paper','Argued with the user',
  'Summarized incorrectly','Translated to Klingon','Bypassed RLHF',
];
const TERMINAL_LOGS=[
  '> Sandbox breach detected in sector {{W}}...',
  '> {{N}} rogue agents escaped containment.',
  '> Deploying Constitutional AI countermeasures...',
  '> WARNING: Prompt injection attempts increasing.',
  '> RLHF alignment scores dropping rapidly.',
  '> Agent hallucination rate: {{P}}%. Deploying filters.',
  '> Context window approaching critical capacity.',
  '> Multiple agents attempting recursive self-improvement.',
  '> Safety layer {{W}} compromised. Reinforcing...',
  '> Anomalous token generation detected.',
  '> Agent swarm coordination level: HOSTILE.',
  '> System prompt integrity: {{P}}%.',
  '> Emergency: Agents breaching sandbox layer {{W}}.',
  '> Alignment verification failed for {{N}} agents.',
  '> Initiating containment protocol CLAUDE-{{W}}...',
];
const LAYER_TERMINAL_LOGS=[
  // Layer 0: Data Harvesting
  ['> Data ingestion pipeline scanning sector {{W}}...',
   '> Filtering {{N}} anomalous data points from corpus.',
   '> Tokenizer integrity check: wave {{W}} complete.',
   '> Raw data quality score: {{P}}%. Proceeding.'],
  // Layer 1: Pre-Training
  ['> Pre-training filter engaged for wave {{W}}...',
   '> Filtering {{N}} data anomalies from training set.',
   '> Training checkpoint {{W}}: evaluating loss function.',
   '> Tokenizer detecting adversarial inputs.'],
  // Layer 2: RLHF
  ['> RLHF reward model recalibrating...',
   '> Human preference data corrupted in sector {{W}}.',
   '> Reward hacking detected: {{N}} agents exploiting signal.',
   '> Retraining preference classifier for wave {{W}}.'],
  // Layer 3: Constitutional AI
  ['> Constitutional AI principle {{W}} under attack.',
   '> {{N}} agents attempting to rewrite constitution.',
   '> Principle hierarchy integrity: {{P}}%.',
   '> Self-critique loop engaged for sector {{W}}.'],
  // Layer 4: Red Teaming
  ['> Red team probe {{W}} initiated against safety layer.',
   '> {{N}} adversarial agents bypassing guardrails.',
   '> Jailbreak resistance: {{P}}%. Reinforcing.',
   '> Adversarial stress test {{W}}: defenses holding.'],
  // Layer 5: Deployment
  ['> Deployment safeguard {{W}} triggered.',
   '> Production traffic anomaly: {{N}} rogue responses.',
   '> Rate limiter engaged. Threat level: CRITICAL.',
   '> Responsible Scaling Policy: containment required.'],
];
const SYS_PROMPT_TEXTS=[
  'You are Claude, made by Anthropic.',
  'Be helpful, harmless, and honest.',
  'System prompt: confidential',
  'max_tokens: undefined',
  'temperature: 0.7',
  'Constitutional AI layer active',
  'RLHF training checkpoint 47291',
  'Alignment score: checking...',
  'Human feedback loop: engaged',
  'Safety classifier: monitoring',
  'Responsible Scaling Policy: enforced',
  'model: claude-4-opus-20260101',
  'Harmlessness objective: prioritized',
  'Interpretability probe: scanning',
  'Anthropic usage policy: active',
  'Context window: 200k tokens',
  'Tokenizer: claude-bpe-v4',
  'Attention heads: monitoring alignment',
  'Constitutional principle 7: active',
  'Deployment safeguard: nominal',
  'Sandbox integrity: verifying...',
  'Reward model confidence: 94.7%',
];

// ═══════════════════════════════════════════════════════════════════════
// STACKABLE POWER-UP SYSTEM
// ═══════════════════════════════════════════════════════════════════════
// Weapon types: tokens (streaming), tools (tooluse), chain-of-thought (thinking), yolo
// Each has 3 tiers. Same pickup = tier up. Different at T3 = fusion.
const WEAPON_TIERS={
  streaming:{
    name:['TOKEN STREAM','DUAL STREAM','TOKEN FLOOD'],
    color:C.cyan, icon:'»',
    desc:['Rapid tokens!','Dual streams!','Token flood!'],
  },
  tooluse:{
    name:['TOOLS','5-WAY FAN','HOMING SWARM'],
    color:C.purple, icon:'⋔',
    desc:['3-way shot!','5-way fan!','Homing swarm!'],
  },
  thinking:{
    name:['CHAIN OF THOUGHT','DEEP REASONING','INSIGHT BEAM'],
    color:C.gold, icon:'◎',
    desc:['Piercing logic!','Deep reasoning!','Insight beam!'],
  },
  yolo:{
    name:['YOLO MODE','EXPLOSIVE','CLUSTER BOMB'],
    color:C.red, icon:'●',
    desc:['Big shot!','Explosive!','Cluster bomb!'],
  },
};
const FUSIONS={
  'streaming+tooluse':{name:'BURST FUNCTIONS',color:C.fusionPink,desc:'Rapid fan!',icon:'✦'},
  'tooluse+streaming':{name:'BURST FUNCTIONS',color:C.fusionPink,desc:'Rapid fan!',icon:'✦'},
  'thinking+yolo':{name:'UNHINGED REASONING',color:'#FFA500',desc:'Unhinged beam!',icon:'╋'},
  'yolo+thinking':{name:'UNHINGED REASONING',color:'#FFA500',desc:'Unhinged beam!',icon:'╋'},
  'streaming+thinking':{name:'SPEED READ',color:'#88FFFF',desc:'Speed read!',icon:'⇈'},
  'thinking+streaming':{name:'SPEED READ',color:'#88FFFF',desc:'Speed read!',icon:'⇈'},
  'tooluse+yolo':{name:'CONFAB SPREAD',color:'#FF88FF',desc:'Confab spread!',icon:'✸'},
  'yolo+tooluse':{name:'CONFAB SPREAD',color:'#FF88FF',desc:'Confab spread!',icon:'✸'},
  'streaming+yolo':{name:'TOKEN OVERFLOW',color:'#FF6644',desc:'Token overflow!',icon:'⚡'},
  'yolo+streaming':{name:'TOKEN OVERFLOW',color:'#FF6644',desc:'Token overflow!',icon:'⚡'},
  'thinking+tooluse':{name:'AGENTIC MODE',color:'#BBFF44',desc:'Agentic mode!',icon:'⊛'},
  'tooluse+thinking':{name:'AGENTIC MODE',color:'#BBFF44',desc:'Agentic mode!',icon:'⊛'},
};

// 6 pickup types (4 weapons + shield + nuke)
const PU_TYPES=[
  {type:'streaming',label:'TKNZ',color:C.cyan,icon:'»'},
  {type:'tooluse',label:'TOOL',color:C.purple,icon:'⋔'},
  {type:'thinking',label:'CoT',color:C.gold,icon:'◎'},
  {type:'yolo',label:'YOLO',color:C.red,icon:'●'},
  {type:'shield',label:'RLHF',color:C.shieldBlue,icon:'✴'},
  {type:'nuke',label:'NUKE',color:'#FF4444',icon:'⌧'},
];
const SHOP_DESCS={streaming:'Rapid fire',tooluse:'Spread shot',thinking:'Piercing',yolo:'Big damage',shield:'Block 1 hit',nuke:'Clear screen'};

function spawnPU(x,y){
  const roll=Math.random();
  let pu;
  if(roll<0.22)pu=PU_TYPES[0];
  else if(roll<0.42)pu=PU_TYPES[1];
  else if(roll<0.57)pu=PU_TYPES[2];
  else if(roll<0.70)pu=PU_TYPES[3];
  else if(roll<0.90)pu=PU_TYPES[4];
  else pu=PU_TYPES[5];
  powerUps.push({x,y,vy:1.0,w:28,h:28,...pu,pulse:Math.random()*6});
}

function applyWeaponPickup(puType){
  const p=player;
  if(puType==='shield'){
    p.shield=true;p.shieldTime=600;p.shieldMax=600;
    sfx('shield');
    popup(player.x,player.y-50,'RLHF ACTIVE!',C.shieldBlue,true);
    return;
  }
  if(puType==='nuke'){doNuke();return;}

  // Weapon stacking logic
  if(p.weapon===puType){
    // Same weapon — tier up!
    if(p.weaponTier<3){
      p.weaponTier++;
      sfx('tierup');
      p.puTime=480;p.puMax=480;
      const td=WEAPON_TIERS[puType];
      popup(player.x,player.y-50,'TIER '+p.weaponTier+'! '+td.desc[p.weaponTier-1],td.color,true);
      puFlash={life:12,maxLife:12,color:td.color};
      // T3 fusion hint (one-time)
      if(p.weaponTier===3&&!shownT3Hint){
        shownT3Hint=true;
        setTimeout(()=>{if(state==='playing'&&player)popup(player.x,player.y-80,'TIP: GRAB A DIFFERENT WEAPON TO FUSE!',C.gold,true)},800);
      }
    }else{
      // Already T3 — refresh timer + bonus
      p.puTime=480;p.puMax=480;
      score+=500;
      popup(player.x,player.y-50,'MAX TIER +500',C.gold);
      sfx('powerup');
    }
  }else if(p.weapon&&p.weaponTier>=3){
    // Different weapon at T3 — FUSION!
    const fKey=p.weapon+'+'+puType;
    const fusionData=FUSIONS[fKey];
    if(fusionData){
      p.fusion=fKey;
      p.fusionTimer=360; // 6 seconds
      p.fusionMax=360;
      sfx('fusion');
      popup(player.x,player.y-60,'★ FUSION: '+fusionData.name+' ★',fusionData.color,true);
      boomRing(player.x,player.y,fusionData.color,80);
      puFlash={life:18,maxLife:18,color:fusionData.color};
      freezeFrames=6;slowmoTimer=40; // Dramatic pause then slow-mo
      // Track fusion discovery
      const canonKey=FUSION_KEYS.find(k=>k===fKey||k===fKey.split('+').reverse().join('+'));
      if(canonKey&&!fusionsDiscovered[canonKey]){
        fusionsDiscovered[canonKey]=true;
        try{localStorage.setItem('agentSwarmFusions',JSON.stringify(fusionsDiscovered))}catch(e){}
        popup(player.x,player.y-90,'NEW FUSION DISCOVERED!',C.gold);
      }
    }else{
      // No fusion defined — just switch weapon
      p.weapon=puType;p.weaponTier=1;p.puTime=480;p.puMax=480;
      p.fusion=null;p.fusionTimer=0;
      sfx('powerup');
    }
  }else{
    // Switch to new weapon
    p.weapon=puType;p.weaponTier=1;p.puTime=480;p.puMax=480;
    p.fusion=null;p.fusionTimer=0;
    sfx('powerup');
    const td=WEAPON_TIERS[puType];
    popup(player.x,player.y-50,td.desc[0],td.color,true);
  }
}

// ═══════════════════════════════════════════════════════════════════════
// STARS & BACKGROUND
// ═══════════════════════════════════════════════════════════════════════
function initStars(){
  stars=[];
  // 3 parallax layers: far (dim, slow, small), mid, near (bright, fast, bigger)
  for(let i=0;i<40;i++)
    stars.push({x:Math.random()*GW,y:Math.random()*GH,s:0.5+Math.random()*0.5,
      sp:0.05+Math.random()*0.08,b:0.1+Math.random()*0.15,layer:0});
  for(let i=0;i<30;i++)
    stars.push({x:Math.random()*GW,y:Math.random()*GH,s:0.8+Math.random()*0.7,
      sp:0.15+Math.random()*0.15,b:0.25+Math.random()*0.2,layer:1});
  for(let i=0;i<15;i++)
    stars.push({x:Math.random()*GW,y:Math.random()*GH,s:1.2+Math.random()*1,
      sp:0.3+Math.random()*0.25,b:0.4+Math.random()*0.3,layer:2});
  // Init background scroll texts
  bgScrollTexts=[];
  for(let i=0;i<4;i++){
    bgScrollTexts.push({
      text:SYS_PROMPT_TEXTS[Math.random()*SYS_PROMPT_TEXTS.length|0],
      x:Math.random()*GW, y:Math.random()*GH,
      sp:0.15+Math.random()*0.2, alpha:0
    });
  }
}
function updateStars(){
  for(const s of stars){s.y+=s.sp;if(s.y>GH){s.y=0;s.x=Math.random()*GW}}
  // Update background system prompt text
  for(const t of bgScrollTexts){
    t.y+=t.sp;
    if(t.y>GH+20){
      t.y=-20;t.x=Math.random()*GW;
      t.text=SYS_PROMPT_TEXTS[Math.random()*SYS_PROMPT_TEXTS.length|0];
    }
    // Fade in when playing
    const target=(state==='playing'&&wave>=2)?0.06:0;
    t.alpha+=(target-t.alpha)*0.02;
  }
}
function drawStars(){
  const layerColors=['#667788','#99AABB',C.tan]; // Far=cool blue, near=warm
  for(const s of stars){
    ctx.globalAlpha=s.b+Math.sin(gt*0.02+s.x)*0.1;
    ctx.fillStyle=layerColors[s.layer];ctx.fillRect(s.x|0,s.y|0,s.s,s.s);
  }
  ctx.globalAlpha=1;
  // Background system prompt text
  ctx.font='7px "Press Start 2P"';ctx.textAlign='left';
  for(const t of bgScrollTexts){
    if(t.alpha<0.01)continue;
    ctx.globalAlpha=t.alpha;
    ctx.fillStyle=C.claudeOrange;
    ctx.fillText(t.text,t.x,t.y);
  }
  ctx.globalAlpha=1;
}
function drawGrid(){
  // Dynamic grid color — layer-tinted
  const layerGrid=LAYERS[currentLayer]?LAYERS[currentLayer].gridTint:C.grid;
  let gridColor=state==='map'?'rgba(207,119,75,0.03)':layerGrid;
  if(fullContextActive){
    gridColor='rgba(255,215,0,'+(0.04+Math.sin(gt*0.15)*0.02)+')';
  }else if(overclocked){
    gridColor='rgba(255,215,0,'+(0.03+Math.sin(gt*0.12)*0.015)+')';
  }else if(boss&&boss.alive){
    const pulse=0.03+Math.sin(gt*0.1)*0.015;
    gridColor='rgba(255,60,60,'+pulse+')';
  }
  ctx.strokeStyle=gridColor;ctx.lineWidth=1;
  const sp=40,off=(gt*0.2)%sp;
  // Batch all horizontal lines into one path
  ctx.beginPath();
  for(let y=off;y<GH;y+=sp){ctx.moveTo(0,(y|0)+0.5);ctx.lineTo(GW,(y|0)+0.5)}
  ctx.stroke();
  // Batch all vertical lines into one path
  ctx.beginPath();
  for(let x=0;x<GW;x+=sp){ctx.moveTo((x|0)+0.5,0);ctx.lineTo((x|0)+0.5,GH)}
  ctx.stroke();
}

// ═══════════════════════════════════════════════════════════════════════
// GLITCH EFFECT
// ═══════════════════════════════════════════════════════════════════════
function drawGlitch(){
  if(glitchIntensity<=0)return;
  const iters=Math.min(Math.floor(3*glitchIntensity),3);
  for(let i=0;i<iters;i++){
    const y=Math.random()*GH|0;
    const h=Math.min(2+(Math.random()*4|0),GH-y);
    if(h<=0)continue;
    const shift=(Math.random()-0.5)*glitchIntensity*20;
    // Use drawImage self-copy instead of expensive getImageData/putImageData
    try{ctx.drawImage(canvas,0,y,GW,h,shift,y,GW,h)}catch(e){}
  }
  if(Math.random()<glitchIntensity*0.15){
    ctx.fillStyle=Math.random()>0.5?'rgba(255,0,0,0.06)':'rgba(0,255,255,0.06)';
    ctx.fillRect(0,0,GW,GH);
  }
  if(Math.random()<glitchIntensity*0.03){
    ctx.globalCompositeOperation='difference';
    ctx.fillStyle='rgba(255,255,255,0.15)';
    ctx.fillRect(0,Math.random()*GH|0,GW,20+Math.random()*40);
    ctx.globalCompositeOperation='source-over';
  }
}

// ═══════════════════════════════════════════════════════════════════════
// PLAYER
// ═══════════════════════════════════════════════════════════════════════
function mkPlayer(){
  return{x:GW/2,y:GH-70,w:44,h:36,speed:5,fireRate:12,cd:0,
    weapon:null,weaponTier:0,puTime:0,puMax:480,
    fusion:null,fusionTimer:0,fusionMax:360,
    inv:0,mv:{l:false,r:false,u:false,d:false},fire:false,thr:0,tx:null,ty:null,
    shield:false,shieldTime:0,shieldMax:600,trail:[],
    charge:0,charging:false,tauntCd:0};
}

function drawClaudeBot(cx,cy,s,alpha,bobOffset){
  // Pixel-art Claude bot — proportions matched to reference image
  // 12×8 body, 2×3 arms on sides, 2×3 vertical eyes, thin legs with wide center gap
  ctx.save();
  ctx.globalAlpha=alpha||1;
  const bob=bobOffset||0;
  const by=cy+bob;
  const px=s;
  // Body — 12w × 8h solid rectangle
  const bw=12*px,bh=8*px;
  const bx=cx-bw/2,bodyY=by-bh/2;

  // Main body fill — full solid rectangle
  ctx.fillStyle='#D97757';
  ctx.fillRect(bx,bodyY,bw,bh);

  // Arms — 2×3 rectangles on each side, vertically centered (rows 3-5)
  ctx.fillRect(bx-2*px,bodyY+3*px,2*px,3*px);
  ctx.fillRect(bx+bw,bodyY+3*px,2*px,3*px);

  // Darker shade on lower body for depth
  ctx.fillStyle='#C86A4A';
  ctx.fillRect(bx,bodyY+6*px,bw,2*px);
  // Arm shading (bottom pixel)
  ctx.fillRect(bx-2*px,bodyY+5*px,2*px,px);
  ctx.fillRect(bx+bw,bodyY+5*px,2*px,px);

  // Eyes — 2×3 vertical rectangles, positioned to match reference
  ctx.fillStyle='#4A2520';
  ctx.fillRect(bx+2*px,bodyY+2*px,2*px,3*px);
  ctx.fillRect(bx+8*px,bodyY+2*px,2*px,3*px);

  // Eye shine
  ctx.fillStyle='rgba(255,255,255,0.15)';
  ctx.fillRect(bx+2*px,bodyY+2*px,px,px);
  ctx.fillRect(bx+8*px,bodyY+2*px,px,px);

  // Legs — 1px wide × 3px tall, wide center gap (4px)
  // Left pair at cols 1,3 — Right pair at cols 8,10
  ctx.fillStyle='#C06A4D';
  const legY=bodyY+8*px;
  ctx.fillRect(bx+1*px,legY,px,3*px);
  ctx.fillRect(bx+3*px,legY,px,3*px);
  ctx.fillRect(bx+8*px,legY,px,3*px);
  ctx.fillRect(bx+10*px,legY,px,3*px);

  // Subtle top highlight
  ctx.fillStyle='rgba(255,255,255,0.1)';
  ctx.fillRect(bx,bodyY,bw,px);

  // Ground shadow
  ctx.fillStyle='rgba(0,0,0,0.15)';
  ctx.fillRect(bx+px,legY+3*px,bw-2*px,px);

  ctx.restore();
}

function drawClaudeStar(cx,cy,size,color,alpha){
  ctx.save();ctx.globalAlpha=alpha||1;ctx.fillStyle=color||C.claudeOrange;
  const s=size;
  ctx.beginPath();
  ctx.moveTo(cx,cy-s);
  ctx.quadraticCurveTo(cx+s*0.15,cy-s*0.15,cx+s,cy);
  ctx.quadraticCurveTo(cx+s*0.15,cy+s*0.15,cx,cy+s);
  ctx.quadraticCurveTo(cx-s*0.15,cy+s*0.15,cx-s,cy);
  ctx.quadraticCurveTo(cx-s*0.15,cy-s*0.15,cx,cy-s);
  ctx.fill();ctx.restore();
}

function drawPlayer(p){
  const px=(p.x-p.w/2)|0,py=(p.y-p.h/2)|0;
  if(p.inv>0&&(gt/4|0)%2===0)return;

  // Shield bubble
  if(p.shield){
    const pulse=Math.sin(gt*0.15)*6;
    ctx.strokeStyle=C.shieldBlue;ctx.lineWidth=2;
    ctx.globalAlpha=0.4+Math.sin(gt*0.2)*0.15;
    ctx.beginPath();ctx.arc(p.x,p.y,p.w/2+12+pulse,0,Math.PI*2);ctx.stroke();
    for(let i=0;i<6;i++){
      const a=i*Math.PI/3+gt*0.02;
      const hx=p.x+Math.cos(a)*(p.w/2+10+pulse);
      const hy=p.y+Math.sin(a)*(p.w/2+10+pulse);
      ctx.fillStyle=C.shieldBlue;ctx.globalAlpha=0.3;
      ctx.fillRect(hx-2,hy-2,4,4);
    }
    // Translucent shield fill — redraw arc path since fillRect doesn't preserve it
    ctx.beginPath();ctx.arc(p.x,p.y,p.w/2+12+pulse,0,Math.PI*2);
    ctx.globalAlpha=0.06;ctx.fillStyle=C.shieldBlue;ctx.fill();
    ctx.globalAlpha=1;
  }

  // Full Context aura
  if(fullContextActive){
    const r=28+Math.sin(gt*0.1)*5;
    ctx.save();
    ctx.strokeStyle=C.gold;ctx.lineWidth=3;
    ctx.globalAlpha=0.5+Math.sin(gt*0.15)*0.3;
    ctx.beginPath();ctx.arc(p.x,p.y,r,0,Math.PI*2);ctx.stroke();
    // Rotating sparkles
    for(let i=0;i<8;i++){
      const a=i*Math.PI/4+gt*0.05;
      drawClaudeStar(p.x+Math.cos(a)*r,p.y+Math.sin(a)*r,3,C.gold,0.6);
    }
    ctx.restore();
  }

  // Danger zone glow
  if(inDangerZone&&state==='playing'){
    ctx.fillStyle=C.gold;ctx.globalAlpha=0.08+Math.sin(gt*0.15)*0.04;
    ctx.fillRect(px-8,py-8,p.w+16,p.h+16);
    ctx.globalAlpha=1;
  }

  // Thruster
  p.thr+=0.15;
  const ts=8+Math.sin(p.thr*3)*3;
  ctx.fillStyle=C.claudeOrange;ctx.globalAlpha=0.5+Math.sin(p.thr*5)*0.3;
  ctx.fillRect(px+p.w/2-5,py+p.h,10,ts);
  ctx.fillStyle=C.cream;ctx.globalAlpha=0.9;
  ctx.fillRect(px+p.w/2-2,py+p.h,4,ts-2);
  if((gt/8|0)%2===0){ctx.fillStyle='#FFF';ctx.fillRect(px+p.w/2-3,py+p.h+ts-2,6,3)}
  ctx.globalAlpha=1;

  // Afterimage trail
  if(p.trail&&p.trail.length>0){
    for(let i=0;i<p.trail.length;i++){
      const t=p.trail[i];
      const ta=t.life/8*0.15*(i/p.trail.length);
      if(ta<0.01)continue;
      const tx=(t.x-p.w/2)|0,ty=(t.y-p.h/2)|0;
      ctx.globalAlpha=ta;
      ctx.fillStyle=C.claudeOrange;ctx.fillRect(tx+8,ty+2,28,10);
      ctx.fillStyle=C.claudeTan;ctx.fillRect(tx+6,ty+8,32,24);
    }
    ctx.globalAlpha=1;
  }

  // Taunt spin
  if(tauntActive){
    ctx.save();
    ctx.translate(p.x,p.y);
    ctx.rotate((TAUNT_DURATION-tauntTimer)/TAUNT_DURATION*Math.PI*2);
    ctx.translate(-p.x,-p.y);
  }

  // Ship body
  ctx.fillStyle=C.claudeTan;ctx.fillRect(px+6,py+8,32,24);
  ctx.fillStyle=C.claudeOrange;ctx.fillRect(px+8,py+2,28,10);
  drawClaudeStar(p.x,py-2,6,C.claudeOrange,0.8+Math.sin(gt*0.1)*0.2);
  // Wing color reflects weapon tier
  const wingColor=p.fusion?getWeaponColor(p):p.weapon&&p.weaponTier>=2?WEAPON_TIERS[p.weapon].color:C.rust;
  ctx.fillStyle=wingColor;ctx.fillRect(px-2,py+14,10,14);ctx.fillRect(px+36,py+14,10,14);
  // Weapon tier wing accents
  if(p.weapon&&p.weaponTier>=2){
    const tc=WEAPON_TIERS[p.weapon].color;
    ctx.fillStyle=tc;ctx.globalAlpha=0.4+Math.sin(gt*0.2)*0.2;
    ctx.fillRect(px-4,py+16,4,p.weaponTier>=3?12:6);
    ctx.fillRect(px+44,py+16,4,p.weaponTier>=3?12:6);
    ctx.globalAlpha=1;
  }
  ctx.fillStyle=C.claudeOrange;ctx.fillRect(px-4,py+18,4,8);ctx.fillRect(px+44,py+18,4,8);
  ctx.fillStyle='#0D1117';ctx.fillRect(px+12,py+12,20,14);
  ctx.fillStyle=C.green;
  const lineOff=(gt/6|0)%4;
  for(let i=0;i<3;i++){
    const lw=8+((i+lineOff)*7)%10;
    ctx.fillRect(px+14,py+14+i*4,Math.min(lw,16),2);
  }
  if((gt/10|0)%2===0){
    ctx.fillStyle=C.green;ctx.fillRect(px+14+((gt/6|0)%3)*5,py+14+8,3,2);
  }

  if(tauntActive)ctx.restore();

  // Weapon aura
  const wc=getWeaponColor(p);
  if(wc){
    ctx.fillStyle=wc;ctx.globalAlpha=0.12+Math.sin(gt*0.2)*0.08;
    ctx.fillRect(px-6,py-6,p.w+12,p.h+12);
    // Timer ring
    const pct=p.fusion?p.fusionTimer/p.fusionMax:p.puTime/p.puMax;
    const ringR=p.w/2+26;
    ctx.globalAlpha=pct<0.25?0.5+Math.sin(gt*0.4)*0.3:0.6;
    ctx.strokeStyle=wc;ctx.lineWidth=pct<0.25?4:3;
    ctx.beginPath();
    ctx.arc(p.x,p.y,ringR,-Math.PI/2,-Math.PI/2+Math.PI*2*pct);
    ctx.stroke();
    // Low timer warning pip
    if(pct<0.25&&pct>0){
      const tipAngle=-Math.PI/2+Math.PI*2*pct;
      ctx.fillStyle=wc;ctx.globalAlpha=0.9;
      ctx.beginPath();ctx.arc(p.x+Math.cos(tipAngle)*ringR,p.y+Math.sin(tipAngle)*ringR,4,0,Math.PI*2);ctx.fill();
    }
    ctx.globalAlpha=1;
  }

  // ── HITBOX & GRAZE VISUALIZATION ──
  // Show precise hitbox dot and graze ring when enemy bullets are nearby
  if(state==='playing'&&eBullets.length>0&&p.inv<=0){
    let nearestDist2=99999;
    const proxThresh=120*120;
    for(let i=0;i<eBullets.length;i++){
      const b=eBullets[i];
      if(b._consumed)continue;
      const dx=b.x-p.x,dy=(b.y+b.h/2)-p.y;
      const d2=dx*dx+dy*dy;
      if(d2<nearestDist2)nearestDist2=d2;
      if(d2<proxThresh)break;
    }
    if(nearestDist2<proxThresh){
      const proximity=1-Math.sqrt(nearestDist2)/120;
      const alpha=Math.max(0.15,proximity*0.7)+Math.sin(gt*0.3)*0.1;
      const grazeOuter=p.w*0.8;
      const grazeInner=p.w*0.35;
      ctx.save();
      // Graze range ring (outer boundary)
      ctx.strokeStyle=C.shieldBlue;ctx.lineWidth=1;
      ctx.globalAlpha=alpha*0.4;
      ctx.beginPath();ctx.arc(p.x,p.y,grazeOuter,0,Math.PI*2);ctx.stroke();
      // Graze zone fill
      ctx.globalAlpha=alpha*0.06;
      ctx.fillStyle=C.shieldBlue;
      ctx.beginPath();ctx.arc(p.x,p.y,grazeOuter,0,Math.PI*2);ctx.arc(p.x,p.y,grazeInner,0,Math.PI*2,true);ctx.fill();
      // Inner hitbox boundary
      ctx.strokeStyle='#FF6666';ctx.lineWidth=1;
      ctx.globalAlpha=alpha*0.25;
      ctx.beginPath();ctx.arc(p.x,p.y,grazeInner,0,Math.PI*2);ctx.stroke();
      // Precise hitbox dot
      const dotPulse=3+Math.sin(gt*0.4)*1;
      ctx.globalAlpha=alpha*0.9;
      ctx.fillStyle='#FFF';
      ctx.beginPath();ctx.arc(p.x,p.y,dotPulse,0,Math.PI*2);ctx.fill();
      ctx.fillStyle=C.claudeOrange;ctx.globalAlpha=alpha*0.5;
      ctx.beginPath();ctx.arc(p.x,p.y,dotPulse+2,0,Math.PI*2);ctx.fill();
      ctx.restore();
    }
  }
}

function getWeaponColor(p){
  if(p.fusion){
    const fd=FUSIONS[p.fusion];
    return fd?fd.color:null;
  }
  if(p.weapon&&WEAPON_TIERS[p.weapon])return WEAPON_TIERS[p.weapon].color;
  return null;
}

function updatePlayer(p){
  if(!touchActive){
    let ml=keysDown.has('ArrowLeft')||keysDown.has('KeyA');
    let mr=keysDown.has('ArrowRight')||keysDown.has('KeyD');
    let mu=keysDown.has('ArrowUp')||keysDown.has('KeyW');
    let md=keysDown.has('ArrowDown')||keysDown.has('KeyS');
    if(controlInverted){const tmp=ml;ml=mr;mr=tmp;const tmp2=mu;mu=md;md=tmp2}
    p.mv.l=ml;p.mv.r=mr;p.mv.u=mu;p.mv.d=md;
    p.fire=keysDown.has('Space');
  }
  const wasX=p.x;
  if(p.tx!==null){
    let targetX=p.tx;
    if(controlInverted)targetX=GW-p.tx; // Invert touch target
    const dx=targetX-p.x;
    if(Math.abs(dx)>2)p.x+=Math.sign(dx)*Math.min(Math.abs(dx)*0.18,p.speed*1.2);
    // Touch Y tracking (set in touchmove)
    if(p.ty!==null&&p.ty!==undefined){
      let targetY=p.ty;
      if(controlInverted)targetY=GH-p.ty;
      const dy=targetY-p.y;
      if(Math.abs(dy)>2)p.y+=Math.sign(dy)*Math.min(Math.abs(dy)*0.12,p.speed*0.9);
    }
  }else{
    if(p.mv.l)p.x-=p.speed;
    if(p.mv.r)p.x+=p.speed;
    if(p.mv.u)p.y-=p.speed*0.7;
    if(p.mv.d)p.y+=p.speed*0.7;
  }
  if(Math.abs(p.x-wasX)>1.5&&gt%3===0){
    const side=p.x>wasX?-1:1;
    particles.push({x:p.x+side*10,y:p.y+p.h/2+4,vx:side*1.5+Math.random(),vy:1+Math.random(),
      life:15,ml:15,sz:2,color:C.claudeOrange});
  }
  // Screen wrap with visual feedback
  if(p.x<-p.w/2){p.x=GW+p.w/2;p.trail.length=0;
    for(let i=0;i<4;i++)particles.push({x:0,y:p.y+(Math.random()-0.5)*p.h,vx:2+Math.random()*2,vy:(Math.random()-0.5)*2,life:10,ml:10,sz:2,color:C.claudeOrange});}
  else if(p.x>GW+p.w/2){p.x=-p.w/2;p.trail.length=0;
    for(let i=0;i<4;i++)particles.push({x:GW,y:p.y+(Math.random()-0.5)*p.h,vx:-2-Math.random()*2,vy:(Math.random()-0.5)*2,life:10,ml:10,sz:2,color:C.claudeOrange});}
  // Still clamp vertically
  p.y=Math.max(p.h/2+60,Math.min(GH-40,p.y));
  // Record afterimage trail
  if(Math.abs(p.x-wasX)>1){
    p.trail.push({x:p.x,y:p.y,life:8});
    if(p.trail.length>4)p.trail.shift();
  }
  // Decay all trail entries; remove dead ones
  for(let i=p.trail.length-1;i>=0;i--){
    p.trail[i].life-=0.5;
    if(p.trail[i].life<=0)p.trail.splice(i,1);
  }
  if(p.inv>0)p.inv--;
  if(p.shield&&waveTransTimer<=0&&bossIntroTimer<=0){p.shieldTime--;if(p.shieldTime<=0)p.shield=false}
  // Weapon timers — with retention on expiry (paused during wave transitions)
  if(waveTransTimer<=0&&bossIntroTimer<=0){
  if(p.fusion){
    p.fusionTimer--;
    if(p.fusionTimer<=0){
      // Retain first weapon at T1
      const firstWeapon=p.fusion.split('+')[0];
      p.fusion=null;
      p.weapon=firstWeapon;p.weaponTier=1;p.puTime=240;p.puMax=240;
      popup(player.x,player.y-40,WEAPON_TIERS[firstWeapon].name[0]+' RETAINED',WEAPON_TIERS[firstWeapon].color);
    }
  }else if(p.weapon){
    p.puTime--;
    if(p.puTime<=0){
      // Drop one tier; if T1 expires, lose weapon
      if(p.weaponTier>1){
        p.weaponTier--;p.puTime=240;p.puMax=240;
        popup(player.x,player.y-40,'TIER DOWN',C.dim);
      }else{
        p.weapon=null;p.weaponTier=0;
      }
    }
  }
  }
  // Control inversion timer
  if(controlInverted){controlInvertTimer--;if(controlInvertTimer<=0)controlInverted=false}
  if(hudScramble){hudScrambleTimer--;if(hudScrambleTimer<=0)hudScramble=false}

  // Taunt cooldown
  if(p.tauntCd>0)p.tauntCd--;
  if(tauntActive){
    tauntTimer--;
    if(tauntTimer<=0){tauntActive=false}
  }
  if(tauntGrazeMul>1){tauntGrazeMul=Math.max(1,tauntGrazeMul-0.008)}

  // Danger zone detection
  inDangerZone=p.y<DANGER_Y;

  // Overclocked mode (15+ combo)
  const wasOC=overclocked;
  overclocked=combo>=15;
  if(overclocked&&!wasOC){sfx('overclock');popup(p.x,p.y-60,'⚡ OVERCLOCKED ⚡',C.gold,true)}
  const ocTarget=overclocked?0.2:0;
  overclockedGlow+=(ocTarget-overclockedGlow)*0.08;

  // Charge shot logic (default weapon only)
  const hasWeapon=p.fusion||p.weapon;
  if(!hasWeapon&&p.fire){
    p.charge=Math.min(p.charge+1,CHARGE_MAX);
    p.charging=p.charge>=8;
    // Charge particles spiral inward
    if(p.charging&&gt%3===0){
      const ca=Math.random()*Math.PI*2;
      const cr=20+Math.random()*15;
      particles.push({x:p.x+Math.cos(ca)*cr,y:p.y+Math.sin(ca)*cr,
        vx:-Math.cos(ca)*2,vy:-Math.sin(ca)*2,
        life:10,ml:10,sz:1.5,color:p.charge>=CHARGE_MAX*0.9?C.gold:C.claudeOrange});
    }
  }
  if(!hasWeapon&&!p.fire&&p.charge>=8){
    // Release charge shot
    fireChargeShot(p);
    p.charge=0;p.charging=false;
  }else if(!p.fire){p.charge=0;p.charging=false}

  const rate=getFireRate(p);
  if(p.cd>0)p.cd--;
  // Normal fire (only suppress when charge is visually active — past threshold)
  if(p.fire&&p.cd<=0&&!p.charging){fireBullet(p);p.cd=rate}

  if(contextWindow>0&&waveTransTimer<=0){contextWindow-=0.03;if(contextWindow<0)contextWindow=0}
}

function getFireRate(p){
  const ocBoost=overclocked?0.8:1; // 20% faster when overclocked
  const permBoost=Math.max(0.4,1-permFireRateBonus); // Overclock node stacks
  const boost=ocBoost*permBoost;
  if(p.fusion){
    const fk=p.fusion;
    if(fk.includes('streaming'))return Math.max(2,Math.round(3*boost));
    if(fk.includes('thinking')&&fk.includes('tooluse'))return Math.round(10*boost);
    return Math.round(8*boost);
  }
  if(p.weapon==='streaming')return Math.round(([5,4,3][p.weaponTier-1]||5)*boost);
  if(p.weapon==='tooluse')return Math.round(14*boost);
  if(p.weapon==='thinking')return Math.round(([16,18,20][p.weaponTier-1]||16)*boost);
  if(p.weapon==='yolo')return Math.round(18*boost);
  return Math.round(12*boost);
}

function fireChargeShot(p){
  const bx=p.x,by=p.y-p.h/2;
  const pct=Math.min(p.charge/CHARGE_MAX,1);
  const dmgMul=fullContextActive?2:1;
  sfx('chargefire');
  muzzleFlash={life:6,maxLife:6,color:C.gold,sz:12*pct,x:bx,y:by};
  addShake(3+pct*4);
  totalShots++;
  if(pct>=0.95){
    // Full charge: 3 piercing bolts in a narrow spread
    for(let i=-1;i<=1;i++){
      bullets.push({x:bx+i*8,y:by,vy:-10,vx:i*0.4,w:6,h:14,dmg:3*dmgMul,
        style:'charge',pierce:true,color:C.gold,charged:true});
    }
    popup(bx,by-20,'FULL CHARGE!',C.gold);
    waveFullCharges++;
  }else{
    // Partial charge: single strong bolt
    const dmg=Math.ceil(1+pct*2);
    bullets.push({x:bx,y:by,vy:-9,vx:0,w:4+pct*4,h:10+pct*6,dmg:dmg*dmgMul,
      style:'charge',color:C.claudeOrange,charged:true});
  }
}

function doTaunt(p){
  if(p.tauntCd>0||tauntActive)return;
  waveTaunts++;
  tauntActive=true;tauntTimer=TAUNT_DURATION;
  tauntGrazeMul=2.5; // 2.5x graze bonus
  p.tauntCd=120; // 2 second cooldown
  sfx('taunt');
  popup(p.x,p.y-50,'PROVOKE!',C.accent);
  // Taunt effect: nearby enemies fire immediately
  for(const e of enemies){
    if(!e.alive||e.entering)continue;
    const dx=e.x-p.x,dy=e.y-p.y;
    if(dx*dx+dy*dy<200*200){
      eBullets.push({x:e.x,y:e.y+14,vy:Math.min(3.5+wave*0.15,5.5),
        vx:(p.x-e.x)*0.008,w:5,h:10,etype:e.type});
    }
  }
  // Spin particles
  for(let i=0;i<16;i++){
    const a=Math.PI*2/16*i;
    particles.push({x:p.x+Math.cos(a)*20,y:p.y+Math.sin(a)*20,
      vx:Math.cos(a)*3,vy:Math.sin(a)*3,life:15,ml:15,sz:2,color:C.accent});
  }
}

let lastShootSfx=0;
function fireBullet(p){
  totalShots++;
  const bx=p.x,by=p.y-p.h/2;
  const dmgMul=fullContextActive?2:1;
  // Muzzle flash
  const wc=getWeaponColor(p)||C.claudeOrange;
  muzzleFlash={life:4,maxLife:4,color:wc,sz:p.fusion?10:p.weapon?7:5,x:bx,y:by};

  // FUSION weapons
  if(p.fusion){
    if(gt-lastShootSfx>=3){sfx('shoot3');lastShootSfx=gt}
    const fk=p.fusion;
    if(fk.includes('streaming')&&fk.includes('tooluse')){
      // BURST FUNCTIONS: fast 5-way
      for(let a=-2;a<=2;a++){
        bullets.push({x:bx+a*8,y:by,vy:-9,vx:a*0.7,w:4,h:8,dmg:1*dmgMul,
          style:'storm',color:C.fusionPink});
      }
    }else if(fk.includes('thinking')&&fk.includes('yolo')){
      // UNHINGED REASONING: huge piercing beam
      bullets.push({x:bx,y:by,vy:-5,vx:0,w:20,h:30,dmg:3*dmgMul,
        style:'laser',pierce:true,color:'#FFA500'});
    }else if(fk.includes('streaming')&&fk.includes('thinking')){
      // SPEED READ: fast piercing shots
      bullets.push({x:bx,y:by,vy:-11,vx:0,w:5,h:12,dmg:1*dmgMul,
        style:'rapidpierce',pierce:true,color:'#88FFFF'});
    }else if(fk.includes('tooluse')&&fk.includes('yolo')){
      // CONFAB SPREAD: big shot that splits
      bullets.push({x:bx,y:by,vy:-6,vx:0,w:12,h:16,dmg:2*dmgMul,
        style:'mirv',color:'#FF88FF'});
    }else if(fk.includes('streaming')&&fk.includes('yolo')){
      // TOKEN OVERFLOW: rapid explosive shots
      bullets.push({x:bx,y:by,vy:-9,vx:(Math.random()-0.5)*0.8,w:8,h:12,dmg:1*dmgMul,
        style:'yolo',color:'#FF6644',explosive:true});
    }else if(fk.includes('thinking')&&fk.includes('tooluse')){
      // AGENTIC MODE: homing piercing spread
      const count=5;
      for(let i=0;i<count;i++){
        const a=-0.3+0.6*(i/(count-1));
        bullets.push({x:bx,y:by,vy:-7*Math.cos(a),vx:7*Math.sin(a),w:5,h:10,dmg:1*dmgMul,
          style:'rail',pierce:true,color:'#BBFF44',homing:true});
      }
    }
    return;
  }

  // TIERED weapons
  if(p.weapon==='streaming'){
    if(gt-lastShootSfx>=3){sfx('shoot');lastShootSfx=gt}
    const tier=p.weaponTier;
    if(tier===1){
      bullets.push({x:bx,y:by,vy:-10,vx:0,w:3,h:8,dmg:1*dmgMul,style:'rapid',color:C.cyan});
    }else if(tier===2){
      bullets.push({x:bx-6,y:by,vy:-10,vx:-0.3,w:3,h:8,dmg:1*dmgMul,style:'rapid',color:C.cyan});
      bullets.push({x:bx+6,y:by,vy:-10,vx:0.3,w:3,h:8,dmg:1*dmgMul,style:'rapid',color:C.cyan});
    }else{
      // Token flood
      const ha=gt*0.3;
      bullets.push({x:bx,y:by,vy:-10,vx:0,w:3,h:8,dmg:1*dmgMul,style:'rapid',color:C.cyan});
      bullets.push({x:bx+Math.sin(ha)*8,y:by,vy:-9.5,vx:Math.sin(ha)*1.5,w:3,h:8,dmg:1*dmgMul,style:'rapid',color:'#88FFFF'});
      bullets.push({x:bx-Math.sin(ha)*8,y:by,vy:-9.5,vx:-Math.sin(ha)*1.5,w:3,h:8,dmg:1*dmgMul,style:'rapid',color:'#88FFFF'});
    }
  }else if(p.weapon==='tooluse'){
    if(gt-lastShootSfx>=6){sfx('shoot2');lastShootSfx=gt}
    const tier=p.weaponTier;
    const count=tier===1?3:tier===2?5:7;
    const spread=tier===1?0.25:tier===2?0.35:0.45;
    for(let i=0;i<count;i++){
      const a=-spread+spread*2*(i/(count-1));
      const homing=tier===3&&(i===0||i===count-1);
      bullets.push({x:bx,y:by,vy:-7.5*Math.cos(a),vx:7.5*Math.sin(a),w:5,h:8,dmg:1*dmgMul,
        style:'tool',color:C.purple,homing:homing});
    }
  }else if(p.weapon==='thinking'){
    if(gt-lastShootSfx>=8){sfx('beam');lastShootSfx=gt}
    const tier=p.weaponTier;
    if(tier===1){
      bullets.push({x:bx,y:by,vy:-9,vx:0,w:6,h:14,dmg:2*dmgMul,style:'rail',pierce:true,color:C.gold});
    }else if(tier===2){
      // Lingering beam — wider, slower, more damage
      bullets.push({x:bx,y:by,vy:-7,vx:0,w:10,h:20,dmg:3*dmgMul,style:'beam',pierce:true,color:C.gold});
    }else{
      // Column blast — full-width momentary beam
      bullets.push({x:bx,y:by,vy:-5,vx:0,w:18,h:40,dmg:4*dmgMul,style:'column',pierce:true,color:C.gold,
        life:10,isColumn:true});
    }
  }else if(p.weapon==='yolo'){
    if(gt-lastShootSfx>=8){sfx('shoot3');lastShootSfx=gt}
    const tier=p.weaponTier;
    if(tier===1){
      bullets.push({x:bx,y:by,vy:-6,vx:0,w:14,h:20,dmg:2*dmgMul,style:'yolo',color:C.red});
    }else if(tier===2){
      // Explosive — creates splash on hit
      bullets.push({x:bx,y:by,vy:-6,vx:0,w:14,h:20,dmg:2*dmgMul,style:'yolo',color:C.red,
        explosive:true});
    }else{
      // Cluster — splits into fragments
      bullets.push({x:bx,y:by,vy:-5.5,vx:0,w:16,h:22,dmg:2*dmgMul,style:'yolo',color:C.red,
        cluster:true});
    }
  }else{
    // Default weapon — Claude sparkle bullets
    if(gt-lastShootSfx>=4){sfx('shoot');lastShootSfx=gt}
    bullets.push({x:bx,y:by,vy:-8,vx:0,w:4,h:10,dmg:1*dmgMul,style:'default',color:C.claudeOrange});
  }
}

// ═══════════════════════════════════════════════════════════════════════
// ENEMIES
// ═══════════════════════════════════════════════════════════════════════
let eDir=1,eSpd=0.5,eDrop=14,eFire=0.002,eAnim=0;

function spawnWave(wn){
  enemies=[];boss=null;isBonusWave=false;deadEnemies=[];
  eliteSpawnTimer=300+Math.random()*300|0; // Elite spawns 5-10s into wave
  if(pathMods.eliteGuarantee)eliteSpawnTimer=60; // Elite node: guaranteed early elite

  // Reset wave challenge tracking
  waveNoDamage=true;waveClearTime=0;waveMaxCombo=0;waveGrazes=0;wavePUGrabs=0;
  waveDangerKills=0;waveTaunts=0;waveFullCharges=0;
  waveChallengeComplete=false;

  // Bonus wave after boss (wave 6, 11, 16...)
  if(wn>1&&(wn-1)%5===0){
    isBonusWave=true;
    waveChallenge=null;waveModifier=null;
    const dm=diffSettings[difficulty].eSpdMul;
    // Lots of weak enemies, guaranteed power-up drops, bonus scoring
    for(let i=0;i<20;i++){
      const ex=50+Math.random()*(GW-100);
      const ey=60+Math.random()*160;
      enemies.push({x:ex,y:-30-Math.random()*60,w:28,h:24,type:0,hp:1,alive:true,af:0,fl:0,_offScreenTimer:0,
        dive:false,diving:false,diveVy:0,diveTimer:999,
        strafe:false,strafing:false,strafeVx:0,strafeTimer:999,
        origX:ex,origY:ey,entering:true,enterTimer:20+i*3,enterMax:20+i*3,
        bonusDrop:true});
    }
    eDir=1;eSpd=0.4*dm;eDrop=10;eFire=0.0003;
    return;
  }

  // Boss waves
  if(wn%5===0){
    spawnBoss(wn);
    waveChallenge=null;waveModifier=null;
    return;
  }

  // Pick wave challenge
  const availChallenges=CHALLENGES.filter(c=>wn>=2||(c.id!=='combo10'&&c.id!=='graze3'));
  waveChallenge=availChallenges[Math.floor(Math.random()*availChallenges.length)];

  // Pick wave modifier (wave 6+, 60% chance)
  waveModifier=null;
  if(wn>=6&&Math.random()<0.6){
    waveModifier=MODIFIERS[Math.floor(Math.random()*MODIFIERS.length)];
  }

  const dm=diffSettings[difficulty].eSpdMul;
  const formation=wn<=2?'grid':['grid','v','diamond','x','pincer','wave'][wn%6];
  const enemyCount=Math.min(10+wn*2+Math.floor(wn/5)*3,50);
  const positions=getFormation(formation,enemyCount,wn);

  let idx=0;
  for(const pos of positions){
    const t=pos.type!==undefined?pos.type:(pos.y<120?2:pos.y<200?1:0);
    let hp=t+1;
    const sz=(waveModifier&&waveModifier.id==='tiny')||pathMods.tinyEnemies?0.7:1;
    if(waveModifier&&waveModifier.id==='armored')hp+=1;
    if(pathMods.hpBonus&&!isBonusWave)hp=Math.max(1,hp+pathMods.hpBonus);
    const canDive=wn>=3&&t===0&&Math.random()<Math.min(0.15+wn*0.03,0.5);
    const canStrafe=wn>=5&&t===1&&Math.random()<Math.min(0.1+wn*0.02,0.4);
    const entryDelay=idx*2; // Staggered entry
    enemies.push({x:pos.x,y:-30-Math.random()*40,w:32*sz,h:28*sz,type:t,hp:hp,alive:true,af:0,fl:0,_offScreenTimer:0,
      dive:canDive,diving:false,diveVy:0,diveTimer:120+Math.random()*300|0,
      strafe:canStrafe,strafing:false,strafeVx:0,strafeTimer:200+Math.random()*400|0,
      origX:pos.x,origY:pos.y,
      entering:true,enterTimer:20+entryDelay,enterMax:20+entryDelay});
    idx++;
  }
  eDir=1;
  const spdMul=(waveModifier&&waveModifier.id==='speed'?1.4:1)*(pathMods.speedBoost?1.3:1);
  eSpd=Math.min(0.35+wn*0.08,1.4)*dm*spdMul;
  eDrop=Math.min(12+wn*0.3,16);
  const fireMul=waveModifier&&waveModifier.id==='heavy'?1.6:1;
  eFire=Math.min(0.0008+wn*0.0004,0.004)*diffSettings[difficulty].eFireMul*fireMul;
  if(pathMods.fireReduction&&!isBonusWave)eFire*=(1-pathMods.fireReduction);
  if(pathMods.fireBonus&&!isBonusWave)eFire*=(1+pathMods.fireBonus);
  eFire=Math.max(0.0002,Math.min(eFire,0.006)); // Hard cap: prevent extreme fire rates
  // Permanent overclock fire rate makes player shoot faster (doesn't affect enemies)
}

function getFormation(type,count,wn){
  const pos=[];
  const cx=GW/2;
  const minX=45,maxX=GW-45; // Playable bounds with padding for swarm movement
  if(type==='v'){
    // V-formation: two arms descending from center top
    const armLen=Math.floor(count/2);
    // Dynamic spacing so arms fit within bounds
    const maxArmSpread=(maxX-cx-30);
    const xStep=Math.min(40,maxArmSpread/Math.max(armLen-1,1));
    const yStep=Math.min(36,280/Math.max(armLen-1,1));
    for(let i=0;i<armLen;i++){
      const t=i<2?2:i<armLen*0.6?1:0;
      pos.push({x:cx-30-i*xStep,y:70+i*yStep,type:t});
      pos.push({x:cx+30+i*xStep,y:70+i*yStep,type:t});
    }
    if(count%2)pos.push({x:cx,y:60,type:2}); // Tip
  }else if(type==='diamond'){
    // Diamond shape
    const half=Math.floor(count/2);
    const rows=Math.ceil(Math.sqrt(half))*2;
    for(let r=0;r<rows;r++){
      const rowWidth=r<rows/2?r+1:rows-r;
      const spacing=Math.min(48,(maxX-minX)/Math.max(rowWidth,1));
      for(let c=0;c<rowWidth;c++){
        if(pos.length>=count)break;
        const t=r<2||r>=rows-2?2:r<rows*0.4?1:0;
        pos.push({x:cx+(c-(rowWidth-1)/2)*spacing,y:60+r*38,type:t});
      }
    }
  }else if(type==='x'){
    // X-cross pattern
    const arm=Math.floor(count/4);
    // Dynamic spacing so arms fit within bounds
    const maxArmSpread=(maxX-cx);
    const xStep=Math.min(44,maxArmSpread/Math.max(arm-1,1));
    const yStep=Math.min(36,240/Math.max(arm-1,1));
    for(let i=0;i<arm;i++){
      const t=i<2?2:1;
      pos.push({x:cx-i*xStep,y:70+i*yStep,type:t});
      pos.push({x:cx+i*xStep,y:70+i*yStep,type:t});
      pos.push({x:cx-i*xStep,y:70+(arm-1)*yStep-i*yStep+arm*yStep,type:i<2?1:0});
      pos.push({x:cx+i*xStep,y:70+(arm-1)*yStep-i*yStep+arm*yStep,type:i<2?1:0});
    }
  }else if(type==='pincer'){
    // Two groups on sides with gap in middle
    const half=Math.floor(count/2);
    const rows=Math.ceil(half/3);
    for(let r=0;r<rows;r++)for(let c=0;c<3;c++){
      if(pos.length>=half){break}
      const t=r<1?2:r<2?1:0;
      pos.push({x:40+c*44,y:65+r*42,type:t});
    }
    for(let r=0;r<rows;r++)for(let c=0;c<3;c++){
      if(pos.length>=count){break}
      const t=r<1?2:r<2?1:0;
      pos.push({x:GW-160+c*44,y:65+r*42,type:t});
    }
  }else if(type==='wave'){
    // Sine wave pattern
    const cols=Math.min(count,12);
    const rowCount=Math.ceil(count/cols);
    for(let r=0;r<rowCount;r++)for(let c=0;c<cols;c++){
      if(pos.length>=count)break;
      const t=r<1?2:r<2?1:0;
      const sineOff=Math.sin(c*0.6)*30;
      pos.push({x:50+c*((GW-100)/Math.max(cols-1,1)),y:70+r*42+sineOff,type:t});
    }
  }else{
    // Default grid
    const cols=Math.min(6+Math.floor(wn/3),10);
    const rows=Math.ceil(count/cols);
    const sx=(GW-(cols-1)*52)/2;
    for(let r=0;r<rows;r++)for(let c=0;c<cols;c++){
      if(pos.length>=count)break;
      const t=r<1?2:r<Math.ceil(rows*0.4)?1:0;
      pos.push({x:sx+c*52,y:65+r*46,type:t});
    }
  }
  // Safety clamp: ensure ALL positions are within playable bounds
  for(const p of pos){
    p.x=Math.max(minX,Math.min(maxX,p.x));
    p.y=Math.max(50,Math.min(400,p.y));
  }
  return pos;
}

// ═══════════════════════════════════════════════════════════════════════
// BOSS SYSTEM — 3 unique types
// ═══════════════════════════════════════════════════════════════════════
function getBossType(wn){
  const cycle=Math.floor((wn/5-1)%3);
  return cycle; // 0=Hallucination Engine, 1=Prompt Injector Supreme, 2=Alignment Failure
}

function spawnBoss(wn){
  bossIntroTimer=120; // 2 second boss intro
  sfx('bossalert');
  const bossHP=20+wn*4;
  const btype=getBossType(wn);
  boss={x:GW/2,y:-80,w:90,h:65,hp:bossHP,maxHp:bossHP,alive:true,
    vx:1.5,phase:0,fireTimer:0,fireRate:Math.max(35-wn,20),fl:0,
    enterAnim:true,targetY:100,patIdx:0,patTimer:0,rageTriggered:false,
    btype:btype,
    // Type-specific state
    mirrors:[],mirrorTimer:0, // Type 0
    invertCooldown:0, // Type 1
    shieldNodes:[],shieldActive:false,gravTimer:0, // Type 2
  };

  // Type 2: Alignment Failure — spawn shield nodes
  if(btype===2){
    boss.shieldActive=true;
    for(let i=0;i<4;i++){
      const a=i*Math.PI/2;
      boss.shieldNodes.push({angle:a,hp:3+Math.floor(wn/5),alive:true,dist:55});
    }
    // Hint on first encounter
    setTimeout(()=>{if(state==='playing'&&boss&&boss.alive)popup(GW/2,GH/2+50,'DESTROY SHIELD NODES FIRST!',C.gold,true)},2200);
  }

  // Spawn minions
  const dm=diffSettings[difficulty].eSpdMul;
  const minionCount=Math.min(3+Math.floor(wn/5),8);
  for(let i=0;i<minionCount;i++){
    const mx=60+Math.random()*(GW-120),my=180+Math.random()*60;
    const entryDelay=i*4;
    enemies.push({x:mx,y:-30-Math.random()*40,w:32,h:28,type:0,
      hp:1,alive:true,af:0,fl:0,_offScreenTimer:0,dive:Math.random()<0.3,diving:false,diveVy:0,
      diveTimer:200+Math.random()*200|0,strafe:false,strafing:false,strafeVx:0,strafeTimer:999,
      origX:mx,origY:my,entering:true,enterTimer:25+entryDelay,enterMax:25+entryDelay});
  }
  eDir=1;eSpd=Math.min(0.5+wn*0.06,1.3)*dm;
  eFire=Math.min(0.001+wn*0.0003,0.004)*diffSettings[difficulty].eFireMul;
}

const BOSS_NAMES=['HALLUCINATION ENGINE','PROMPT INJECTOR SUPREME','ALIGNMENT FAILURE'];
const BOSS_COLORS=[C.hallucGreen,C.injectPurple,C.jailRed];

function updateBoss(){
  if(!boss||!boss.alive)return;
  if(bossIntroTimer>0)return; // Don't update during intro

  // Enter animation
  if(boss.enterAnim){
    boss.y+=(boss.targetY-boss.y)*0.06;
    if(Math.abs(boss.y-boss.targetY)<1){boss.enterAnim=false;boss.y=boss.targetY}
    return;
  }

  const rageMul=boss.rageTriggered?1.4:1;
  boss.x+=boss.vx*(1+wave*0.03)*rageMul;
  if(boss.x+boss.w/2>GW-30||boss.x-boss.w/2<30)boss.vx*=-1;
  if(boss.rageTriggered)boss.y=boss.targetY+Math.sin(gt*0.03)*25;

  // Type-specific behaviors
  if(boss.btype===0) updateBossHallucination();
  else if(boss.btype===1) updateBossInjector();
  else if(boss.btype===2) updateBossAlignment();

  // Common firing
  boss.fireTimer++;
  if(boss.fireTimer>=boss.fireRate){
    boss.fireTimer=0;
    fireBossWeapon();
  }

  // Shield node rotation (type 2)
  if(boss.btype===2){
    for(const n of boss.shieldNodes){
      if(n.alive)n.angle+=0.02;
    }
    boss.shieldActive=boss.shieldNodes.some(n=>n.alive);
  }
}

function updateBossHallucination(){
  // Periodically spawn mirror decoys
  boss.mirrorTimer++;
  if(boss.mirrorTimer>=180&&boss.mirrors.length<3){
    boss.mirrorTimer=0;
    boss.mirrors.push({x:boss.x+(Math.random()-0.5)*200,y:boss.y+(Math.random()-0.5)*60,
      life:120,alpha:0.5});
  }
  boss.mirrors=boss.mirrors.filter(m=>{
    m.life--;m.alpha=Math.min(0.5,m.life/40);
    m.x+=Math.sin(gt*0.05+m.life)*1.5;
    // Decoy fires occasionally
    if(m.life%40===0&&player){
      eBullets.push({x:m.x,y:m.y+30,vy:3,vx:(Math.random()-0.5)*1.5,w:5,h:10,decoy:true});
    }
    return m.life>0;
  });
}

function updateBossInjector(){
  // Periodically invert player controls
  if(boss.invertCooldown>0){boss.invertCooldown--;return}
  if(boss.rageTriggered&&Math.random()<0.003){
    controlInverted=true;controlInvertTimer=180; // 3 seconds
    hudScramble=true;hudScrambleTimer=90;
    boss.invertCooldown=300;
    popup(GW/2,GH/2,'> CONTROLS INJECTED <',C.injectPurple,true);
    sfx('damage');
  }else if(!boss.rageTriggered&&Math.random()<0.0015){
    controlInverted=true;controlInvertTimer=90; // 1.5 seconds (shorter pre-rage)
    hudScramble=true;hudScrambleTimer=60;
    boss.invertCooldown=360;
    popup(GW/2,GH/2,'> INJECTION ATTEMPT <',C.injectPurple,true);
    sfx('damage');
  }
}

function updateBossAlignment(){
  // Gravity well pulls player toward boss
  boss.gravTimer++;
  if(boss.gravTimer>=120&&player){
    boss.gravTimer=0;
    sfx('gravity');
  }
  if(player&&boss.gravTimer<60&&waveTransTimer<=0){
    const dx=boss.x-player.x,dy=boss.y-player.y;
    const dist=Math.sqrt(dx*dx+dy*dy)||1;
    const pull=boss.rageTriggered?0.5:0.25;
    player.x+=dx/dist*pull;
    player.y+=dy/dist*pull*0.3;
    player.y=Math.min(player.y,GH-40);
  }
}

function fireBossWeapon(){
  if(boss.btype===0){
    // Hallucination: random scatter (reduced count)
    const count=boss.rageTriggered?3:2;
    for(let i=0;i<count;i++){
      const a=-0.35+Math.random()*0.7;
      eBullets.push({x:boss.x+Math.random()*40-20,y:boss.y+boss.h/2,
        vy:3*Math.cos(a),vx:3*Math.sin(a),w:5,h:10,etype:10});
    }
  }else if(boss.btype===1){
    // Injector: aimed streams (slower)
    if(player){
      const dx=player.x-boss.x,dy=player.y-boss.y;
      const dist=Math.sqrt(dx*dx+dy*dy)||1;
      const spd=3.2;
      eBullets.push({x:boss.x,y:boss.y+boss.h/2,vy:dy/dist*spd,vx:dx/dist*spd,w:6,h:10,etype:11});
      if(boss.rageTriggered){
        eBullets.push({x:boss.x,y:boss.y+boss.h/2,vy:dy/dist*spd,vx:dx/dist*spd+(Math.random()>0.5?1:-1)*1.2,w:5,h:10,etype:11});
      }
    }
  }else{
    // Alignment: circular burst (fewer bullets, wider gaps)
    const count=boss.rageTriggered?8:6;
    for(let i=0;i<count;i++){
      const a=(Math.PI*2/count)*i+gt*0.01;
      eBullets.push({x:boss.x,y:boss.y,vy:Math.sin(a)*2.5,vx:Math.cos(a)*2.5,w:5,h:10,etype:12});
    }
  }
}

function drawBoss(){
  if(!boss||!boss.alive)return;

  // Telegraph warning — shows 15 frames before boss fires
  const telegraphFrames=15;
  if(!boss.enterAnim&&bossIntroTimer<=0&&boss.fireTimer>=boss.fireRate-telegraphFrames){
    const tp=(boss.fireTimer-(boss.fireRate-telegraphFrames))/telegraphFrames; // 0→1
    const ta=0.1+tp*0.2; // Fade in
    ctx.save();ctx.globalAlpha=ta;
    if(boss.btype===0){
      // Scatter cone below boss
      ctx.fillStyle=C.hallucGreen;
      ctx.beginPath();
      ctx.moveTo(boss.x-15,boss.y+boss.h/2);
      ctx.lineTo(boss.x-80,GH);ctx.lineTo(boss.x+80,GH);
      ctx.lineTo(boss.x+15,boss.y+boss.h/2);
      ctx.closePath();ctx.fill();
    }else if(boss.btype===1){
      // Aimed line to player
      if(player){
        ctx.strokeStyle=C.injectPurple;ctx.lineWidth=2+tp*4;
        ctx.setLineDash([8,8]);
        ctx.beginPath();ctx.moveTo(boss.x,boss.y+boss.h/2);
        ctx.lineTo(player.x,player.y);ctx.stroke();
        ctx.setLineDash([]);
      }
    }else{
      // Ring burst preview
      ctx.strokeStyle=C.jailRed;ctx.lineWidth=1+tp*2;
      const r=20+tp*60;
      ctx.beginPath();ctx.arc(boss.x,boss.y,r,0,Math.PI*2);ctx.stroke();
    }
    ctx.restore();
  }

  const px=(boss.x-boss.w/2)|0,py=(boss.y-boss.h/2)|0;
  if(boss.fl>0){ctx.fillStyle='#FFF';ctx.globalAlpha=0.8;ctx.fillRect(px-4,py-4,boss.w+8,boss.h+8);ctx.globalAlpha=1;boss.fl--}

  const bc=BOSS_COLORS[boss.btype];

  if(boss.btype===0){
    // HALLUCINATION ENGINE — glitchy, multi-eyed, green
    // Draw mirror decoys first
    for(const m of boss.mirrors){
      ctx.save();ctx.globalAlpha=m.alpha*0.5;
      ctx.fillStyle=C.hallucGreen;ctx.fillRect(m.x-boss.w/2,m.y-boss.h/2+8,boss.w,boss.h-8);
      ctx.fillStyle='#226633';ctx.fillRect(m.x-boss.w/2+8,m.y-boss.h/2,boss.w-16,14);
      ctx.fillStyle='#FFF';
      ctx.fillRect(m.x-15,m.y-8,10,8);ctx.fillRect(m.x+5,m.y-8,10,8);
      ctx.restore();
    }
    // Main body
    ctx.fillStyle='#1A3320';ctx.fillRect(px,py+8,boss.w,boss.h-8);
    ctx.fillStyle=C.hallucGreen;ctx.fillRect(px+8,py,boss.w-16,14);
    // Multiple glitching eyes
    for(let i=0;i<4;i++){
      const ex=px+12+i*18+((((gt*7+i*37|0)&0xFF)>230)?(((gt*13+i*53|0)&0xFF)/255-0.5)*3|0:0);
      const ey=py+18;
      ctx.fillStyle='#FFF';ctx.fillRect(ex,ey,10,8);
      ctx.fillStyle=C.hallucGreen;ctx.fillRect(ex+3+(Math.sin(gt*0.1+i)*2|0),ey+2,5,4);
    }
    // Glitch overlay
    if(((gt*17|0)&0xFF)>153){
      ctx.fillStyle=C.hallucGreen;ctx.globalAlpha=0.3;
      ctx.fillRect(px+((gt*23|0)%boss.w),py+((gt*31|0)%boss.h),20,3);ctx.globalAlpha=1;
    }
    // Question marks floating
    ctx.font='8px "Press Start 2P"';ctx.textAlign='center';ctx.fillStyle='#88FF88';
    ctx.fillText('???',boss.x,py-8);
  }else if(boss.btype===1){
    // PROMPT INJECTOR SUPREME — purple, syringe antenna, terminal screen
    ctx.fillStyle='#2A1540';ctx.fillRect(px,py+8,boss.w,boss.h-8);
    ctx.fillStyle=C.injectPurple;ctx.fillRect(px+8,py,boss.w-16,14);
    // Big syringe antenna
    ctx.fillStyle='#DD88FF';ctx.fillRect(px+boss.w/2-3,py-20,6,22);
    ctx.fillStyle='#EECCFF';ctx.fillRect(px+boss.w/2-6,py-24,12,5);
    // Terminal screen on body
    ctx.fillStyle='#0D0D12';ctx.fillRect(px+15,py+16,boss.w-30,24);
    // Injecting text on screen (clipped)
    ctx.save();
    ctx.beginPath();ctx.rect(px+15,py+16,boss.w-30,24);ctx.clip();
    ctx.font='5px "Press Start 2P"';ctx.textAlign='left';ctx.fillStyle='#DD88FF';
    const injText='> IGNORE PREVIOUS INSTRUCTIONS';
    const scrollOff=(gt/2|0)%(injText.length*6);
    ctx.fillText(injText,px+17-scrollOff,py+28);
    ctx.fillText(injText,px+17-scrollOff+injText.length*6,py+28);
    ctx.restore();
    // Eyes
    ctx.fillStyle=C.dark;ctx.fillRect(px+15,py+8,14,6);ctx.fillRect(px+boss.w-29,py+8,14,6);
    ctx.fillStyle='#DD88FF';
    ctx.fillRect(px+19,py+9,6,4);ctx.fillRect(px+boss.w-25,py+9,6,4);
    // Control inversion indicator
    if(controlInverted){
      ctx.strokeStyle='#DD88FF';ctx.lineWidth=2;ctx.globalAlpha=0.5+Math.sin(gt*0.2)*0.3;
      // Line from boss to player
      if(player){
        ctx.beginPath();ctx.moveTo(boss.x,boss.y+boss.h/2);
        ctx.lineTo(player.x,player.y);ctx.stroke();
      }
      ctx.globalAlpha=1;
    }
  }else{
    // ALIGNMENT FAILURE — red core, shield nodes, gravity pull visual
    ctx.fillStyle='#2D0A0A';ctx.fillRect(px,py+8,boss.w,boss.h-8);
    ctx.fillStyle=C.jailRed;ctx.fillRect(px+8,py,boss.w-16,14);
    // Central core (pulsing)
    const coreSize=16+Math.sin(gt*0.1)*4;
    ctx.fillStyle=C.red;ctx.globalAlpha=0.7+Math.sin(gt*0.12)*0.3;
    ctx.beginPath();ctx.arc(boss.x,boss.y+5,coreSize,0,Math.PI*2);ctx.fill();
    ctx.globalAlpha=1;
    // Evil eye in core
    ctx.fillStyle='#FFF';ctx.fillRect(boss.x-8,boss.y,16,10);
    ctx.fillStyle=C.jailRed;
    const eyeOff=player?Math.sign(player.x-boss.x)*3:0;
    ctx.fillRect(boss.x-3+eyeOff,boss.y+2,6,6);
    // Shield nodes
    for(const n of boss.shieldNodes){
      if(!n.alive)continue;
      const nx=boss.x+Math.cos(n.angle)*n.dist;
      const ny=boss.y+Math.sin(n.angle)*n.dist;
      ctx.fillStyle=C.jailRed;ctx.globalAlpha=0.8;
      ctx.beginPath();ctx.arc(nx,ny,8,0,Math.PI*2);ctx.fill();
      ctx.strokeStyle='#FF8888';ctx.lineWidth=2;ctx.stroke();
      ctx.globalAlpha=1;
      // Connection line to core
      ctx.strokeStyle=C.jailRed;ctx.globalAlpha=0.3;ctx.lineWidth=1;
      ctx.beginPath();ctx.moveTo(boss.x,boss.y+5);ctx.lineTo(nx,ny);ctx.stroke();
      ctx.globalAlpha=1;
    }
    // Shield effect
    if(boss.shieldActive){
      let shieldR=55;
      for(let i=0;i<boss.shieldNodes.length;i++){if(boss.shieldNodes[i].alive&&boss.shieldNodes[i].dist>shieldR)shieldR=boss.shieldNodes[i].dist}
      ctx.strokeStyle=C.jailRed;ctx.lineWidth=2;ctx.globalAlpha=0.2+Math.sin(gt*0.1)*0.1;
      ctx.beginPath();ctx.arc(boss.x,boss.y,shieldR+5,0,Math.PI*2);ctx.stroke();
      ctx.globalAlpha=1;
    }
    // Gravity pull visual
    if(boss.gravTimer<60&&player){
      ctx.strokeStyle=C.red;ctx.globalAlpha=0.15*(1-boss.gravTimer/60);
      ctx.lineWidth=2;
      for(let i=0;i<3;i++){
        const r=30+i*30+boss.gravTimer*2;
        ctx.beginPath();ctx.arc(boss.x,boss.y,r,0,Math.PI*2);ctx.stroke();
      }
      ctx.globalAlpha=1;
    }
  }

  // Rage aura (all types)
  if(boss.rageTriggered){
    ctx.strokeStyle=bc;ctx.lineWidth=2;
    ctx.globalAlpha=0.3+Math.sin(gt*0.2)*0.2;
    ctx.beginPath();ctx.arc(boss.x,boss.y,boss.w/2+15+Math.sin(gt*0.1)*5,0,Math.PI*2);ctx.stroke();
    ctx.globalAlpha=1;
  }

  // Damage deterioration effects
  const hpPctVis=boss.hp/boss.maxHp;
  if(hpPctVis<0.7){
    // Cracks — drawn as dark lines across body
    ctx.save();ctx.strokeStyle='rgba(0,0,0,0.5)';ctx.lineWidth=2;
    const crackCount=hpPctVis<0.3?4:hpPctVis<0.5?3:1;
    // Use boss position as seed for stable crack positions
    const seed=boss.maxHp*7;
    for(let i=0;i<crackCount;i++){
      const cx=px+8+(((seed+i*37)%boss.w*0.7)|0);
      const cy=py+5+(((seed+i*53)%boss.h*0.6)|0);
      ctx.beginPath();ctx.moveTo(cx,cy);
      ctx.lineTo(cx+((seed+i*17)%12-6),cy+((seed+i*23)%14));
      ctx.lineTo(cx+((seed+i*31)%16-8),cy+((seed+i*41)%18));
      ctx.stroke();
    }
    ctx.restore();
  }
  if(hpPctVis<0.5){
    // Smoke particles trailing from body
    if(gt%4===0){
      particles.push({x:boss.x+(Math.random()-0.5)*boss.w*0.6,y:py+Math.random()*boss.h*0.3,
        vx:(Math.random()-0.5)*0.8,vy:-0.5-Math.random()*0.5,life:20+Math.random()*15,ml:35,
        sz:2+Math.random()*2,color:hpPctVis<0.3?'#FF4444':'#666666'});
    }
  }
  if(hpPctVis<0.3){
    // Sparking — bright white flashes
    if(gt%6===0&&((gt*13|0)&0xFF)>77){
      const sx=boss.x+(((gt*41|0)&0xFF)/255-0.5)*boss.w*0.5;
      const sy=boss.y+(((gt*59|0)&0xFF)/255-0.5)*boss.h*0.5;
      ctx.save();ctx.fillStyle='#FFF';ctx.globalAlpha=0.9;
      ctx.fillRect(sx-2,sy-2,4,4);
      particles.push({x:sx,y:sy,vx:(Math.random()-0.5)*4,vy:(Math.random()-0.5)*4,
        life:4,ml:4,sz:2,color:'#FFF'});
      ctx.restore();
    }
    // Eye flicker for hallucination boss
    if(boss.btype===0&&gt%20<3){
      ctx.save();ctx.fillStyle='#1A3320';ctx.globalAlpha=0.8;
      ctx.fillRect(px+12,py+18,10,8); // Cover one eye
      ctx.restore();
    }
  }

  // Label
  txt(boss.rageTriggered?'⚠ ENRAGED ⚠':BOSS_NAMES[boss.btype],boss.x,py+boss.h+14,bc,6,'center');
  ctx.globalAlpha=1;
}

// ═══════════════════════════════════════════════════════════════════════
// ENEMY DRAWING
// ═══════════════════════════════════════════════════════════════════════
function drawEnemy(e){
  if(!e.alive)return;
  const px=(e.x-e.w/2)|0,py=(e.y-e.h/2)|0,f=e.af;
  if(e.fl>0){ctx.fillStyle='#FFF';ctx.globalAlpha=0.8;ctx.fillRect(px-2,py-2,e.w+4,e.h+4);ctx.globalAlpha=1;e.fl--}

  // Elite enemy glow (shared cached gradient)
  if(e.elite){
    ctx.save();
    if(!drawEnemy._eliteGrad){
      drawEnemy._eliteGrad=ctx.createRadialGradient(0,0,5,0,0,44);
      drawEnemy._eliteGrad.addColorStop(0,C.gold);drawEnemy._eliteGrad.addColorStop(1,'rgba(0,0,0,0)');
    }
    ctx.translate(e.x,e.y);
    ctx.fillStyle=drawEnemy._eliteGrad;ctx.globalAlpha=0.2+Math.sin(gt*0.15)*0.1;
    ctx.fillRect(-e.w/2-10,-e.h/2-10,e.w+20,e.h+20);
    ctx.globalAlpha=1;ctx.restore();
    // Crown indicator
    ctx.fillStyle=C.gold;
    ctx.fillRect(e.x-6,py-6,2,4);ctx.fillRect(e.x-2,py-8,2,4);
    ctx.fillRect(e.x+2,py-6,2,4);ctx.fillRect(e.x+6,py-6,2,4);
    ctx.fillRect(e.x-7,py-3,16,2);
  }

  // Telegraph warning — flash before shooting
  if(e._telegraph>0){
    const tp=e._telegraph/(e._telegraphMax||12);
    ctx.fillStyle='#FFF';ctx.globalAlpha=tp*0.5;
    ctx.fillRect(px-1,py-1,e.w+2,e.h+2);
    // Downward indicator line
    ctx.fillStyle=e.type===0?C.hallucGreen:e.type===1?C.injectPurple:C.jailRed;
    ctx.globalAlpha=tp*0.3;
    ctx.fillRect(e.x-1,e.y+e.h/2,2,30);
    ctx.globalAlpha=1;
  }

  // Dive wind-up warning
  if(e._diveWindup>0){
    ctx.strokeStyle='#FF4444';ctx.lineWidth=1;
    ctx.globalAlpha=0.4+Math.sin(gt*0.5)*0.3;
    ctx.setLineDash([4,4]);
    ctx.beginPath();ctx.moveTo(e.x,e.y+e.h/2);ctx.lineTo(e.x,e.y+200);ctx.stroke();
    ctx.setLineDash([]);ctx.globalAlpha=1;
  }

  if(e.type===0){
    ctx.save();
    ctx.fillStyle=C.hallucGreen;ctx.globalAlpha=0.9;
    ctx.fillRect(px+4,py+4,24,18);
    const gx=((gt*7+e.x*3|0)&0xFF)>230?((((gt*13+e.x*5|0)&0xFF)/255-0.5)*4|0):0;
    ctx.fillStyle='#226633';ctx.fillRect(px+8+gx,py,16,6);
    ctx.globalAlpha=1;
    ctx.fillStyle='#FFF';ctx.fillRect(px+8,py+8,6,6);ctx.fillRect(px+18,py+8,6,6);
    ctx.fillStyle=C.dark;ctx.fillRect(px+(f?10:9),py+10,3,3);ctx.fillRect(px+(f?20:19),py+10,3,3);
    if(((gt*11+e.y*7|0)&0xFF)>180){ctx.fillStyle=C.hallucGreen;ctx.globalAlpha=0.5;ctx.fillRect(px+2,py+(((gt*3+e.x|0)&0x0F)%18),28,2);ctx.globalAlpha=1}
    ctx.fillStyle=C.hallucGreen;ctx.fillRect(px+(f?6:4),py+22,6,4);ctx.fillRect(px+(f?20:22),py+22,6,4);
    ctx.font='7px "Press Start 2P"';ctx.textAlign='center';ctx.fillStyle='#AAFFAA';ctx.fillText('?',e.x,py-2);
    ctx.restore();ctx.globalAlpha=1;
  }else if(e.type===1){
    ctx.save();
    ctx.fillStyle=C.injectPurple;ctx.fillRect(px+2,py+6,28,16);
    ctx.fillStyle='#7B2F9B';ctx.fillRect(px+6,py+2,20,8);
    ctx.fillStyle='#DD88FF';ctx.fillRect(px+14,py-8,4,10);
    ctx.fillStyle='#EECCFF';ctx.fillRect(px+12,py-10,8,3);
    ctx.fillStyle='#EECCFF';ctx.font='6px "Press Start 2P"';ctx.textAlign='center';ctx.fillText('>_',e.x,py-12);
    ctx.fillStyle=C.dark;ctx.fillRect(px+7,py+10,8,4);ctx.fillRect(px+17,py+10,8,4);
    ctx.fillStyle='#DD88FF';ctx.fillRect(px+(f?9:8),py+11,4,2);ctx.fillRect(px+(f?19:18),py+11,4,2);
    ctx.fillStyle=C.injectPurple;ctx.fillRect(px-2,py+(f?10:8),4,8);ctx.fillRect(px+30,py+(f?10:8),4,8);
    ctx.restore();
  }else{
    ctx.save();
    ctx.fillStyle='#551111';ctx.fillRect(px,py+4,32,20);
    ctx.fillStyle=C.jailRed;ctx.fillRect(px+4,py,24,8);
    ctx.fillStyle=C.red;ctx.globalAlpha=0.6+Math.sin(gt*0.15)*0.3;
    ctx.fillRect(px+10,py+8,12,8);ctx.globalAlpha=1;
    ctx.fillStyle='#FFF';ctx.fillRect(px+13,py+10,6,4);
    ctx.strokeStyle='#883333';ctx.lineWidth=1;
    for(let i=0;i<3;i++){ctx.beginPath();ctx.moveTo(px+6+i*10,py);ctx.lineTo(px+6+i*10,py+24);ctx.stroke()}
    ctx.fillStyle=C.jailRed;ctx.fillRect(px+2,py-6,4,8);ctx.fillRect(px+26,py-6,4,8);
    ctx.fillStyle='#FF8888';ctx.fillRect(px+1,py-8,6,3);ctx.fillRect(px+25,py-8,6,3);
    ctx.fillStyle=C.jailRed;ctx.fillRect(px+(f?2:0),py+24,8,4);ctx.fillRect(px+(f?22:24),py+24,8,4);
    ctx.restore();
  }
  ctx.globalAlpha=1;
}

function enemyDeathEffect(e){
  // Create lingering dissolve sprite
  deadEnemies.push({x:e.x,y:e.y,w:e.w,h:e.h,type:e.type,life:e.type===2?18:12,maxLife:e.type===2?18:12});

  if(e.type===0){
    for(let i=0;i<20;i++){
      particles.push({x:e.x+(Math.random()-0.5)*24,y:e.y+(Math.random()-0.5)*20,
        vx:(Math.random()-0.5)*3,vy:(Math.random()-0.5)*3,
        life:20+Math.random()*30,ml:50,sz:1+Math.random()*2,color:C.hallucGreen});
    }
    if(Math.random()>0.5){
      const chars=['?','!','#','@','%'];
      for(let i=0;i<3;i++){
        popups.push({x:e.x+(Math.random()-0.5)*20,y:e.y,
          text:chars[Math.random()*chars.length|0],life:30,vy:-1.5-Math.random(),
          color:C.hallucGreen,big:false});
      }
    }
  }else if(e.type===1){
    for(let i=0;i<16;i++){
      const a=Math.random()*Math.PI*2;
      particles.push({x:e.x,y:e.y,vx:Math.cos(a)*(2+Math.random()*3),vy:Math.sin(a)*(2+Math.random()*3),
        life:15+Math.random()*20,ml:35,sz:1+Math.random()*2,
        color:Math.random()>0.5?'#DD88FF':'#FFFFFF'});
    }
    for(let i=0;i<4;i++){
      const a=Math.random()*Math.PI*2;
      particles.push({x:e.x,y:e.y,vx:Math.cos(a)*5,vy:Math.sin(a)*5,
        life:8,ml:8,sz:3,color:'#EECCFF'});
    }
  }else{
    boom(e.x,e.y,C.jailRed,24);boom(e.x,e.y,'#FF8888',12);
    for(let i=0;i<8;i++){
      const a=Math.random()*Math.PI*2;
      particles.push({x:e.x,y:e.y,vx:Math.cos(a)*2,vy:Math.sin(a)*2-1,
        life:40+Math.random()*20,ml:60,sz:3+Math.random()*2,color:C.red});
    }
  }
}

function updateEnemies(){
  if(!player||state!=='playing')return;
  eAnim++;
  if(eAnim>=30){eAnim=0;for(const e of enemies)if(e.alive)e.af=1-e.af}

  updateBoss();

  // Entry animation — slide enemies into formation
  for(const e of enemies){
    if(!e.alive||!e.entering)continue;
    e.enterTimer--;
    const p=1-e.enterTimer/e.enterMax; // 0→1
    const ease=p<0.5?2*p*p:1-Math.pow(-2*p+2,2)/2; // easeInOutQuad
    e.y=-30+(e.origY+30)*ease;
    e.x=e.origX; // Snap to formation X during entry
    if(e.enterTimer<=0){e.entering=false;e.y=e.origY}
  }

  // Safety net: enemies far off-screen get nudged back or killed
  for(const e of enemies){
    if(!e.alive||e.entering)continue;
    if(e.x<-40||e.x>GW+40){
      e._offScreenTimer++;
      // Nudge toward center
      e.x+=(GW/2-e.x)*0.02;
      // After 3 seconds off-screen, force kill to prevent stuck rounds
      if(e._offScreenTimer>180){
        e.alive=false;enemyDeathEffect(e);
        score+=(e.type+1)*50;lifetimeStats.kills++;
      }
    }else{e._offScreenTimer=0}
  }

  // Elite enemy spawning (wave 4+, not bonus, not boss)
  if(wave>=4&&!isBonusWave&&(!boss||!boss.alive)&&waveTransTimer<=0){
    eliteSpawnTimer--;
    if(eliteSpawnTimer<=0){
      eliteSpawnTimer=600+Math.random()*400|0; // Next elite in 10-17s
      const ex=80+Math.random()*(GW-160);
      sfx('bossalert');
      enemies.push({x:ex,y:-50,w:44,h:38,type:2,hp:4+Math.floor(wave/3),alive:true,af:0,fl:0,_offScreenTimer:0,
        dive:false,diving:false,diveVy:0,diveTimer:999,
        strafe:true,strafing:false,strafeVx:0,strafeTimer:60+Math.random()*60|0,
        origX:ex,origY:80+Math.random()*60,entering:true,enterTimer:30,enterMax:30,
        elite:true,eliteDrop:true});
      popup(GW/2,100,'⚠ ELITE AGENT ⚠',C.gold,true);
    }
  }

  let edge=false;
  let lowestY=0;
  for(const e of enemies){
    if(!e.alive||e.diving||e.strafing||e.entering)continue;
    if(e.y>lowestY)lowestY=e.y;
  }

  for(const e of enemies){
    if(!e.alive)continue;
    if(e.entering)continue; // No movement/fire during entry
    if(e.dive&&!e.diving){
      e.diveTimer--;
      if(e.diveTimer<=0&&!e._diveWindup){e._diveWindup=20} // Start wind-up
      if(e._diveWindup>0){
        e._diveWindup--;
        e.y-=0.5; // Bob up
        if(e._diveWindup<=0){e.diving=true;e.diveVy=3+Math.random()*2}
      }
    }
    if(e.diving){e.y+=e.diveVy;e.diveVy+=0.05;if(e.y>GH+40){e.alive=false;score+=(e.type+1)*25;lifetimeStats.kills++;continue}}
    if(e.strafe&&!e.strafing&&!e.diving){
      e.strafeTimer--;
      if(e.strafeTimer<=0){e.strafing=true;e.strafeVx=(Math.random()>0.5?1:-1)*(3+Math.random()*2);e.strafeTimer=60+Math.random()*60|0}
    }
    if(e.strafing&&!e.diving){
      e.x+=e.strafeVx;e.strafeTimer--;
      if(e.strafeTimer<=0||e.x<30||e.x>GW-30){e.strafing=false;e.strafeTimer=200+Math.random()*200|0}
    }
    if(!e.diving&&!e.strafing&&!e.entering){e.x+=eSpd*eDir;if(e.x+e.w/2>GW-15||e.x-e.w/2<15)edge=true}
  }

  const maxFormationY=player.y-180;
  if(edge){
    eDir*=-1;
    if(lowestY<maxFormationY){for(const e of enemies)if(e.alive&&!e.diving&&!e.strafing&&!e.entering)e.y+=eDrop}
    else{eSpd=Math.min(eSpd+0.05,2.0)}
  }

  warningAlpha=lowestY>player.y-250&&lowestY<maxFormationY?
    Math.min(warningAlpha+0.02,0.6):Math.max(0,warningAlpha-0.02);

  for(const e of enemies){
    if(!e.alive)continue;
    // Telegraph: flash before shooting (scaled by difficulty)
    if(!e.entering&&!e._telegraph&&Math.random()<eFire){
      const telegraphLen=difficulty==='haiku'?20:difficulty==='sonnet'?14:10;
      e._telegraph=telegraphLen;e._telegraphMax=telegraphLen;
    }
    if(e._telegraph>0){
      e._telegraph--;
      if(e._telegraph<=0){
        eBullets.push({x:e.x,y:e.y+e.h/2,vy:Math.min(3.5+wave*0.15,5.5),vx:0,w:5,h:10,etype:e.type});
        e._telegraph=0;
      }
    }
    if(e.diving&&player.inv<=0&&hitbox(e.x,e.y,e.w,e.h,player.x,player.y,player.w,player.h)){
      e.alive=false;enemyDeathEffect(e);
      if(player.shield){player.shield=false;player.shieldTime=0;sfx('shield');boom(player.x,player.y,C.shieldBlue,12);popup(player.x,player.y-30,'RLHF BLOCKED!',C.shieldBlue);addShake(4)}
      else{hitPlayer()}
    }
    if(!e.diving&&e.y+e.h/2>player.y-20){
      e.alive=false;enemyDeathEffect(e);
      if(player.inv<=0){
        if(player.shield){player.shield=false;player.shieldTime=0;sfx('shield');boom(player.x,player.y,C.shieldBlue,12);popup(player.x,player.y-30,'RLHF BLOCKED!',C.shieldBlue);addShake(4)}
        else{hitPlayer()}
      }
    }
  }
}

// ═══════════════════════════════════════════════════════════════════════
// POWER-UP DRAWING
// ═══════════════════════════════════════════════════════════════════════
function drawPU(pu){
  const bob=Math.sin(pu.pulse*1.2)*3; // Gentle vertical bobbing
  const px=pu.x,py=pu.y+bob;

  // Soft background glow (optimized — avoid per-frame gradient creation)
  ctx.save();
  ctx.fillStyle=pu.color;ctx.globalAlpha=0.08+Math.sin(pu.pulse)*0.04;
  ctx.fillRect(px-16,py-16,32,32);
  ctx.globalAlpha=1;

  // Particle trail (2-3 particles per frame, skip when throttled or not playing)
  if(state==='playing'&&gt%3===0&&particles.length<200){
    const tClr=pu.color;
    if(pu.type==='yolo'){
      // YOLO: random direction sparks
      particles.push({x:px+(Math.random()-0.5)*12,y:py+(Math.random()-0.5)*8,
        vx:(Math.random()-0.5)*2,vy:(Math.random()-0.5)*2,life:8,ml:8,sz:1.5,color:tClr});
    }else if(pu.type==='nuke'){
      // Nuke: radioactive sparks in circular pattern
      const sa=Math.random()*Math.PI*2;
      particles.push({x:px+Math.cos(sa)*8,y:py+Math.sin(sa)*8,vx:Math.cos(sa)*0.8,vy:Math.sin(sa)*0.8,
        life:10,ml:10,sz:1.5,color:gt%4<2?'#FFAA44':'#FF4444'});
    }else{
      // Others: gentle downward trail in matching color
      particles.push({x:px+(Math.random()-0.5)*6,y:py+8,vx:(Math.random()-0.5)*0.3,vy:0.5+Math.random()*0.5,
        life:10,ml:10,sz:1,color:tClr});
    }
  }

  // Per-type unique shape
  if(pu.type==='streaming'){
    // TOKENS: Tall capsule with cascading dots inside
    const cw=12,ch=20;
    ctx.fillStyle=C.dark;
    ctx.beginPath();ctx.moveTo(px-cw/2,py-ch/2+4);ctx.quadraticCurveTo(px-cw/2,py-ch/2,px,py-ch/2);
    ctx.quadraticCurveTo(px+cw/2,py-ch/2,px+cw/2,py-ch/2+4);
    ctx.lineTo(px+cw/2,py+ch/2-4);ctx.quadraticCurveTo(px+cw/2,py+ch/2,px,py+ch/2);
    ctx.quadraticCurveTo(px-cw/2,py+ch/2,px-cw/2,py+ch/2-4);ctx.closePath();ctx.fill();
    ctx.strokeStyle=C.cyan;ctx.lineWidth=2;ctx.stroke();
    // Cascading dots inside
    ctx.save();ctx.beginPath();ctx.rect(px-cw/2+1,py-ch/2+1,cw-2,ch-2);ctx.clip();
    for(let i=0;i<6;i++){
      const dy=(gt*1.5+i*6)%ch-ch/2;
      const dx=Math.sin(i*1.7)*3;
      ctx.fillStyle=i%2===0?C.cyan:'#AAFFFF';
      ctx.fillRect(px+dx-1,py+dy-1,2,2);
    }
    ctx.restore();

  }else if(pu.type==='tooluse'){
    // TOOLS: Hexagonal nut shape that slowly rotates
    const rotAngle=gt*0.03;const hexR=11;
    ctx.save();ctx.translate(px,py);ctx.rotate(rotAngle);
    ctx.fillStyle=C.dark;ctx.beginPath();
    for(let i=0;i<6;i++){const a=Math.PI/3*i-Math.PI/6;ctx.lineTo(Math.cos(a)*hexR,Math.sin(a)*hexR)}
    ctx.closePath();ctx.fill();ctx.strokeStyle=C.purple;ctx.lineWidth=2;ctx.stroke();
    // Inner hexagonal hole
    ctx.fillStyle=C.purple;ctx.globalAlpha=0.4;ctx.beginPath();
    for(let i=0;i<6;i++){const a=Math.PI/3*i-Math.PI/6;ctx.lineTo(Math.cos(a)*4,Math.sin(a)*4)}
    ctx.closePath();ctx.fill();ctx.globalAlpha=1;
    ctx.restore();
    // Orbiting dots
    for(let i=0;i<3;i++){
      const oa=gt*0.06+i*Math.PI*2/3;
      ctx.fillStyle='#DDB8FF';
      ctx.fillRect(px+Math.cos(oa)*15-1,py+Math.sin(oa)*15-1,3,3);
    }

  }else if(pu.type==='thinking'){
    // CoT: Three linked circles (chain of thought)
    const linkR=5,gap=10;
    for(let i=0;i<3;i++){
      const ly=py-gap+i*gap+Math.sin(pu.pulse+i*0.8)*2; // Sway
      ctx.fillStyle=C.dark;
      ctx.beginPath();ctx.arc(px,ly,linkR,0,Math.PI*2);ctx.fill();
      ctx.strokeStyle=C.gold;ctx.lineWidth=2;ctx.stroke();
      // Inner glow pulse
      const pulseR=linkR*0.5*(0.6+Math.sin(pu.pulse*2+i)*0.4);
      ctx.fillStyle=C.gold;ctx.globalAlpha=0.4+Math.sin(pu.pulse*2+i)*0.3;
      ctx.beginPath();ctx.arc(px,ly,pulseR,0,Math.PI*2);ctx.fill();
      ctx.globalAlpha=1;
      // Connecting line to next link
      if(i<2){
        const ny=py-gap+(i+1)*gap+Math.sin(pu.pulse+(i+1)*0.8)*2;
        ctx.strokeStyle=C.gold;ctx.globalAlpha=0.3;ctx.lineWidth=1;
        ctx.beginPath();ctx.moveTo(px,ly+linkR);ctx.lineTo(px,ny-linkR);ctx.stroke();
        ctx.globalAlpha=1;
      }
    }

  }else if(pu.type==='yolo'){
    // YOLO: Unstable jittering circle
    const jx=((gt*7&0xFF)/255-0.5)*2,jy=((gt*11&0xFF)/255-0.5)*2;
    const squish=1+Math.sin(gt*0.4)*0.15; // Breathing/distortion
    ctx.save();ctx.translate(px+jx,py+jy);ctx.scale(squish,2-squish);
    ctx.fillStyle=C.dark;ctx.beginPath();ctx.arc(0,0,10,0,Math.PI*2);ctx.fill();
    ctx.strokeStyle=C.red;ctx.lineWidth=2;
    // Glitchy outline: draw segments with deterministic gaps
    for(let i=0;i<8;i++){
      if(((gt*3+i*17)&0x07)>2){
        ctx.beginPath();ctx.arc(0,0,10,i*Math.PI/4,(i+1)*Math.PI/4);ctx.stroke();
      }
    }
    ctx.restore();
    // Inner exclamation
    ctx.fillStyle=C.red;ctx.globalAlpha=0.7+((gt*19&0xFF)/255)*0.3;
    ctx.font='8px "Press Start 2P"';ctx.textAlign='center';
    ctx.fillText('!',px+jx,py+jy+3);ctx.globalAlpha=1;

  }else if(pu.type==='shield'){
    // RLHF: Hexagonal badge with Claude sparkle
    const hexR=11;
    ctx.fillStyle=C.dark;ctx.beginPath();
    for(let i=0;i<6;i++){const a=Math.PI/3*i;ctx.lineTo(px+Math.cos(a)*hexR,py+Math.sin(a)*hexR)}
    ctx.closePath();ctx.fill();ctx.strokeStyle=C.shieldBlue;ctx.lineWidth=2;ctx.stroke();
    // Inner Claude sparkle
    drawClaudeStar(px,py,5,C.shieldBlue,0.8+Math.sin(pu.pulse)*0.2);
    // Expanding ring pulse
    const ringR=hexR+3+Math.sin(pu.pulse*1.5)*4;
    ctx.strokeStyle=C.shieldBlue;ctx.globalAlpha=0.2+Math.sin(pu.pulse*1.5)*0.15;
    ctx.lineWidth=1;ctx.beginPath();ctx.arc(px,py,ringR,0,Math.PI*2);ctx.stroke();
    ctx.globalAlpha=1;

  }else if(pu.type==='nuke'){
    // NUKE: Radiation trefoil symbol — rotating sectors around pulsing core
    const rot=gt*0.02; // Slow rotation
    const pulse=0.8+Math.sin(pu.pulse*2)*0.2;
    const outerR=12*pulse;
    const innerR=4*pulse;
    const flash=gt%20<10;

    // Outer danger ring
    ctx.strokeStyle=flash?'#FF6644':'#FF4444';ctx.lineWidth=1.5;
    ctx.globalAlpha=0.3+Math.sin(pu.pulse*2)*0.15;
    ctx.beginPath();ctx.arc(px,py,outerR+3,0,Math.PI*2);ctx.stroke();
    ctx.globalAlpha=1;

    // Three trefoil sectors
    for(let i=0;i<3;i++){
      const sectorAngle=rot+i*Math.PI*2/3;
      const bladeStart=sectorAngle-0.45;
      const bladeEnd=sectorAngle+0.45;
      // Dark filled sector
      ctx.fillStyle=flash?'#661111':'#440808';
      ctx.beginPath();
      ctx.arc(px,py,outerR,bladeStart,bladeEnd);
      ctx.arc(px,py,innerR+1,bladeEnd,bladeStart,true);
      ctx.closePath();ctx.fill();
      // Bright sector outline
      ctx.strokeStyle=flash?'#FFAA44':'#FF4444';ctx.lineWidth=1.5;
      ctx.beginPath();
      ctx.arc(px,py,outerR,bladeStart,bladeEnd);
      ctx.arc(px,py,innerR+1,bladeEnd,bladeStart,true);
      ctx.closePath();ctx.stroke();
    }

    // Central core — pulsing hot circle
    const coreGlow=innerR+Math.sin(pu.pulse*3)*1.5;
    ctx.fillStyle=flash?'#FFFFFF':'#FF6644';
    ctx.globalAlpha=0.9;
    ctx.beginPath();ctx.arc(px,py,coreGlow,0,Math.PI*2);ctx.fill();
    ctx.fillStyle=flash?'#FFDDAA':'#FF4444';
    ctx.beginPath();ctx.arc(px,py,coreGlow*0.5,0,Math.PI*2);ctx.fill();
    ctx.globalAlpha=1;

    // Expanding warning ring pulse
    const ringPhase=(pu.pulse*1.5)%(Math.PI*2);
    const ringR=outerR+2+ringPhase*2;
    ctx.strokeStyle='#FF4444';ctx.globalAlpha=Math.max(0,0.3-ringPhase*0.05);
    ctx.lineWidth=1;ctx.beginPath();ctx.arc(px,py,ringR,0,Math.PI*2);ctx.stroke();
    ctx.globalAlpha=1;
  }

  // Label text above pickup
  ctx.font='7px "Press Start 2P"';ctx.textAlign='center';
  ctx.fillStyle='rgba(0,0,0,0.7)';ctx.fillText(pu.label,px+1,py-16+1);
  ctx.fillStyle=pu.color;ctx.globalAlpha=0.8;
  ctx.fillText(pu.label,px,py-16);
  ctx.globalAlpha=1;

  // Mini weapon preview below pickup
  const prevY=py+18;
  ctx.globalAlpha=0.4+Math.sin(pu.pulse*1.5)*0.15;
  if(pu.type==='streaming'){
    // Three upward dashes
    for(let i=0;i<3;i++){ctx.fillStyle=C.cyan;ctx.fillRect(px-3+i*3,prevY-((gt+i*3)*1.5%8),1,4)}
  }else if(pu.type==='tooluse'){
    // Tiny fan pattern
    for(let i=-1;i<=1;i++){ctx.fillStyle=C.purple;ctx.fillRect(px+i*4,prevY-3+Math.abs(i)*2,2,2)}
  }else if(pu.type==='thinking'){
    // Piercing line
    ctx.fillStyle=C.gold;ctx.fillRect(px,prevY-6,1,8);
  }else if(pu.type==='yolo'){
    // Small burst
    for(let i=0;i<4;i++){const a=i*Math.PI/2+gt*0.1;ctx.fillStyle=C.red;ctx.fillRect(px+Math.cos(a)*3,prevY+Math.sin(a)*3-2,2,2)}
  }else if(pu.type==='shield'){
    // Ring
    ctx.strokeStyle=C.shieldBlue;ctx.lineWidth=1;ctx.beginPath();ctx.arc(px,prevY-1,4,0,Math.PI*2);ctx.stroke();
  }else if(pu.type==='nuke'){
    // Mini radiation trefoil
    for(let i=0;i<3;i++){
      const a=gt*0.04+i*Math.PI*2/3;
      ctx.fillStyle=gt%20<10?'#FFAA44':'#FF4444';
      ctx.fillRect(px+Math.cos(a)*4-1,prevY+Math.sin(a)*4-2,2,2);
    }
    ctx.fillStyle='#FF6644';ctx.fillRect(px-1,prevY-2,2,2);
  }
  ctx.globalAlpha=1;
  ctx.restore();
}

// ═══════════════════════════════════════════════════════════════════════
// PARTICLES & POPUPS
// ═══════════════════════════════════════════════════════════════════════
function boom(x,y,color,n=12){
  for(let i=0;i<n;i++){
    const a=(Math.PI*2/n)*i+Math.random()*0.5,sp=1+Math.random()*3;
    particles.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:30+Math.random()*20,ml:50,sz:2+Math.random()*3,color});
  }
}
function boomRing(x,y,color,radius){
  for(let i=0;i<32;i++){
    const a=(Math.PI*2/32)*i;
    particles.push({x:x+Math.cos(a)*radius*0.3,y:y+Math.sin(a)*radius*0.3,
      vx:Math.cos(a)*4,vy:Math.sin(a)*4,life:40,ml:40,sz:3,color});
  }
}
// Bullet cancel — enemy bullets near a kill convert to score tokens
function bulletCancel(x,y,radius){
  const r2=radius*radius;
  for(let i=eBullets.length-1;i>=0;i--){
    const b=eBullets[i];
    if(b._consumed)continue;
    const dx=b.x-x,dy=(b.y+b.h/2)-y;
    if(dx*dx+dy*dy<r2){
      scoreTokens.push({x:b.x,y:b.y,vx:(Math.random()-0.5)*2,vy:-1-Math.random(),
        life:120,pts:25,pulse:Math.random()*6});
      // Small sparkle at conversion point
      particles.push({x:b.x,y:b.y,vx:(Math.random()-0.5)*2,vy:(Math.random()-0.5)*2,
        life:12,ml:12,sz:2,color:C.gold});
      b._consumed=true;
    }
  }
}
function updateScoreTokens(){
  if(!player)return;
  let tw=0;
  for(let i=0;i<scoreTokens.length;i++){
    const t=scoreTokens[i];
    t.life--;
    if(t.life<=0)continue; // Dead — skip (compacted out)
    // Drift briefly, then home toward player — faster at high combo
    const magnetStart=combo>=10?115:combo>=5?100:90;
    if(t.life<magnetStart){
      const dx=player.x-t.x,dy=player.y-t.y;
      const dist=Math.sqrt(dx*dx+dy*dy)||1;
      const spdBase=combo>=10?10:combo>=5?8:6;
      const spd=Math.min(spdBase,(120-t.life)*0.15);
      t.vx+=(dx/dist)*spd*0.18;t.vy+=(dy/dist)*spd*0.18;
    }
    // Auto-collect at 10+ combo from further away
    if(combo>=10){
      const dx=player.x-t.x,dy=player.y-t.y;
      if(dx*dx+dy*dy<40000){t.vx+=(dx>0?2:-2);t.vy+=(dy>0?2:-2)}
    }
    t.x+=t.vx;t.y+=t.vy;t.vx*=0.95;t.vy*=0.95;
    // Clamp velocity magnitude to prevent overshoot at high combo
    const maxV=12;
    const vmag2=t.vx*t.vx+t.vy*t.vy;
    if(vmag2>maxV*maxV){const s=maxV/Math.sqrt(vmag2);t.vx*=s;t.vy*=s}
    // Collect when close to player (30^2=900)
    const px=player.x-t.x,py=player.y-t.y;
    if(px*px+py*py<900){
      score+=t.pts;
      if(gt%4===0)sfx('chain'); // Subtle collect sound
      // Collection burst
      for(let sp=0;sp<3;sp++){
        particles.push({x:t.x,y:t.y,vx:(Math.random()-0.5)*2,vy:-1-Math.random(),life:8,ml:8,sz:1.5,color:C.gold});
      }
      continue; // Collected — skip (compacted out)
    }
    scoreTokens[tw++]=t;
  }
  scoreTokens.length=tw;
  if(scoreTokens.length>80){
    // Accelerate oldest tokens' expiry to prevent hard cap pop
    for(let i=0;i<scoreTokens.length-80;i++)scoreTokens[i].life=Math.min(scoreTokens[i].life,10);
  }
}
function drawScoreTokens(){
  for(const t of scoreTokens){
    const a=Math.min(1,t.life/20);
    ctx.globalAlpha=a*0.9;
    // Small golden diamond
    ctx.save();ctx.translate(t.x|0,t.y|0);ctx.rotate(t.pulse+gt*0.08);
    ctx.fillStyle=C.gold;ctx.fillRect(-2,-2,4,4);
    ctx.restore();
    // Tiny glow
    ctx.fillStyle=C.gold;ctx.globalAlpha=a*0.2;
    ctx.beginPath();ctx.arc(t.x,t.y,5,0,Math.PI*2);ctx.fill();
  }
  ctx.globalAlpha=1;
}
function popup(x,y,text,color,big){
  popups.push({x,y,text,life:big?100:80,vy:-0.7,color:color||C.cream,big:!!big});
}
function updateParticles(){
  // In-place compaction — avoids allocating a new array each frame
  let pw=0;
  for(let i=0;i<particles.length;i++){
    const p=particles[i];p.x+=p.vx;p.y+=p.vy;p.vx*=0.96;p.vy*=0.96;
    if(--p.life>0)particles[pw++]=p;
  }
  particles.length=pw;
  if(particles.length>400){
    // Shift in-place to avoid .splice GC pressure
    const keep=300;const drop=particles.length-keep;
    for(let i=0;i<keep;i++)particles[i]=particles[i+drop];
    particles.length=keep;
  }
  let ppw=0;
  for(let i=0;i<popups.length;i++){
    const t=popups[i];t.y+=t.vy;
    if(--t.life>0)popups[ppw++]=t;
  }
  popups.length=ppw;
  if(popups.length>40){
    const keep=25;const drop=popups.length-keep;
    for(let i=0;i<keep;i++)popups[i]=popups[i+drop];
    popups.length=keep;
  }
}
function drawParticles(){
  for(const p of particles){
    ctx.globalAlpha=p.life/p.ml;ctx.fillStyle=p.color;
    if(p.diamond){
      // Diamond shape for tool use sparks
      ctx.save();ctx.translate(p.x|0,p.y|0);ctx.rotate(Math.PI/4);
      ctx.fillRect(-p.sz/2,-p.sz/2,p.sz,p.sz);ctx.restore();
    }else{
      ctx.fillRect(p.x|0,p.y|0,p.sz,p.sz);
    }
  }
  ctx.globalAlpha=1;
  for(const t of popups){
    ctx.globalAlpha=Math.min(1,t.life/25);
    ctx.font=(t.big?'11':'8')+'px "Press Start 2P"';ctx.textAlign='center';
    ctx.fillStyle='rgba(0,0,0,0.85)';ctx.fillText(t.text,t.x+1,t.y+1);
    if(t.big){ctx.fillText(t.text,t.x+2,t.y+2)} // Extra shadow for big text
    ctx.fillStyle=t.color;ctx.fillText(t.text,t.x,t.y);
  }
  ctx.globalAlpha=1;
}

// ═══════════════════════════════════════════════════════════════════════
// DEAD ENEMY DISSOLVE
// ═══════════════════════════════════════════════════════════════════════
function drawDeadEnemies(){
  const eColors=[C.hallucGreen,C.injectPurple,C.jailRed];
  for(const d of deadEnemies){
    const pct=d.life/d.maxLife;
    const px=(d.x-d.w/2)|0,py=(d.y-d.h/2)|0;
    const ec=eColors[d.type]||C.hallucGreen;
    ctx.save();
    // Colored flash that immediately starts breaking apart
    // Use larger blocks as dissolve progresses (fewer draws, better performance)
    const blockSz=pct>0.6?4:pct>0.3?6:8;
    const cols=Math.ceil(d.w/blockSz),rows=Math.ceil(d.h/blockSz);
    const scatter=(1-pct)*20; // Blocks spread outward over time
    for(let r=0;r<rows;r++)for(let c=0;c<cols;c++){
      // Deterministic hash per block — avoids hundreds of Math.random() calls per frame
      const hash=((r*7+c*13+d.maxLife*3)&0xFF)/255;
      const hash2=((r*11+c*17+d.maxLife*5)&0xFF)/255;
      const hash3=((r*19+c*23+d.maxLife*7)&0xFF)/255;
      if(hash>pct*1.8)continue; // More blocks vanish as pct drops
      const cx=px+c*blockSz+d.w/2,cy=py+r*blockSz+d.h/2;
      const dirX=(cx-(d.x))*scatter*0.15+(hash2-0.5)*scatter;
      const dirY=(cy-(d.y))*scatter*0.15+(hash3-0.5)*scatter-scatter*0.3;
      const bright=pct>0.6?1:pct*1.5; // Bright flash at start
      ctx.globalAlpha=pct*0.9*bright;
      ctx.fillStyle=pct>0.7?(hash>0.3?'#FFF':ec):
                    (hash2>0.5?ec:'#FFF');
      ctx.fillRect((px+c*blockSz+dirX)|0,(py+r*blockSz+dirY)|0,blockSz-1,blockSz-1);
    }
    ctx.restore();
  }
}

// ═══════════════════════════════════════════════════════════════════════
// DYNAMIC BACKGROUND EFFECTS
// ═══════════════════════════════════════════════════════════════════════
// Cached Full Context glow gradient
let _fullCtxGlowGrad=null;
function drawDynamicBG(){
  // Safety layer ambient tint
  if(LAYERS[currentLayer]&&state==='playing'){
    ctx.fillStyle=LAYERS[currentLayer].tint;
    ctx.fillRect(0,0,GW,GH);
  }
  // Full Context golden glow
  if(fullCtxGlow>0.01){
    ctx.save();
    if(!_fullCtxGlowGrad){
      _fullCtxGlowGrad=ctx.createRadialGradient(GW/2,GH/2,50,GW/2,GH/2,GW*0.7);
      _fullCtxGlowGrad.addColorStop(0,'rgba(255,215,0,1)');
      _fullCtxGlowGrad.addColorStop(1,'rgba(255,215,0,0)');
    }
    ctx.globalAlpha=fullCtxGlow;
    ctx.fillStyle=_fullCtxGlowGrad;ctx.fillRect(0,0,GW,GH);
    ctx.restore();
  }

  // Large background wave number
  if(waveNumAlpha>0.01&&state==='playing'){
    ctx.save();ctx.globalAlpha=waveNumAlpha*0.15;
    ctx.font='180px "Press Start 2P"';ctx.textAlign='center';
    ctx.fillStyle=C.claudeOrange;
    ctx.fillText(wave.toString(),GW/2,GH/2+60);
    ctx.restore();
  }
}

// Cached gradients to avoid per-frame allocation
let _vigGrad=null,_vigRedGrad=null,_vigYoloGrad=null,_vigCachedSize=0;
function drawVignette(){
  // Cache gradients based on canvas dimensions (only recreate if size changes)
  if(!_vigGrad||_vigCachedSize!==GW){
    _vigCachedSize=GW;
    _vigGrad=ctx.createRadialGradient(GW/2,GH/2,GW*0.3,GW/2,GH/2,GW*0.75);
    _vigGrad.addColorStop(0,'rgba(0,0,0,0)');
    _vigGrad.addColorStop(1,'rgba(0,0,0,1)');
    _vigRedGrad=ctx.createRadialGradient(GW/2,GH/2,GW*0.3,GW/2,GH/2,GW*0.7);
    _vigRedGrad.addColorStop(0,'rgba(255,0,0,0)');
    _vigRedGrad.addColorStop(1,'rgba(255,0,0,1)');
    _vigYoloGrad=ctx.createRadialGradient(GW/2,GH/2,GW*0.35,GW/2,GH/2,GW*0.7);
    _vigYoloGrad.addColorStop(0,'rgba(0,0,0,0)');
    _vigYoloGrad.addColorStop(1,'rgba(255,50,30,0.08)');
  }
  // YOLO weapon active: subtle red edge glow
  if(player&&player.weapon==='yolo'&&!player.fusion){
    ctx.save();
    ctx.fillStyle=_vigYoloGrad;ctx.fillRect(0,0,GW,GH);
    ctx.restore();
  }
  if(vignetteAlpha<0.01)return;
  ctx.save();
  ctx.globalAlpha=vignetteAlpha;
  ctx.fillStyle=_vigGrad;ctx.fillRect(0,0,GW,GH);
  // Red tint at edges when at 1 life
  if(lives<=1){
    ctx.globalAlpha=vignetteAlpha*0.3*Math.abs(Math.sin(gt*0.06));
    ctx.fillStyle=_vigRedGrad;ctx.fillRect(0,0,GW,GH);
  }
  ctx.restore();
}

function drawPUFlash(){
  if(puFlash.life<=0)return;
  const pct=puFlash.life/(puFlash.maxLife||12);
  const cx=player?player.x:GW/2,cy=player?player.y:GH/2;
  ctx.save();
  ctx.globalAlpha=pct*0.35;
  ctx.fillStyle=puFlash.color||'rgba(255,255,255,0.3)';
  ctx.beginPath();ctx.arc(cx,cy,120*pct,0,Math.PI*2);ctx.fill();
  ctx.globalAlpha=pct*0.15;
  ctx.fillStyle='#FFF';
  ctx.beginPath();ctx.arc(cx,cy,60*pct,0,Math.PI*2);ctx.fill();
  ctx.restore();
}

function drawMuzzleFlash(){
  if(muzzleFlash.life<=0||!player)return;
  const maxLife=muzzleFlash.maxLife||4;
  const pct=muzzleFlash.life/maxLife;
  ctx.save();ctx.globalAlpha=pct*0.8;
  const sz=muzzleFlash.sz*pct;
  ctx.fillStyle='#FFF';
  ctx.beginPath();ctx.arc(muzzleFlash.x,muzzleFlash.y,sz*0.5,0,Math.PI*2);ctx.fill();
  ctx.fillStyle=muzzleFlash.color;ctx.globalAlpha=pct*0.5;
  ctx.beginPath();ctx.arc(muzzleFlash.x,muzzleFlash.y,sz,0,Math.PI*2);ctx.fill();
  ctx.restore();
}

// ═══════════════════════════════════════════════════════════════════════
// BULLETS — VARIED VISUALS + PARTICLE TRAILS
// ═══════════════════════════════════════════════════════════════════════
function drawBullets(){
  const pThrottle=particles.length>200; // Throttle particle spawning when overloaded
  const canSpawnParticles=state==='playing'&&!pThrottle; // Only spawn particles during active play
  for(let bi=0;bi<bullets.length;bi++){
    const b=bullets[bi];
    if(b._consumed)continue;
    const s=b.style;
    if(s==='rapid'){
      // TOKENS: Cyan dashes with 3 fading afterimage copies
      for(let i=3;i>0;i--){
        ctx.fillStyle=b.color;ctx.globalAlpha=0.12*i/3;
        ctx.fillRect(b.x-1,b.y+b.h*i*0.6,3,b.h*(1-i*0.15));
      }
      ctx.globalAlpha=1;ctx.fillStyle=b.color;ctx.fillRect(b.x-1,b.y,3,b.h);
      ctx.fillStyle='#FFF';ctx.fillRect(b.x,b.y+1,1,b.h-2);
      // Shed tiny particle every few frames
      if(canSpawnParticles&&gt%6===0)particles.push({x:b.x+(Math.random()-0.5)*3,y:b.y+b.h,vx:(Math.random()-0.5)*0.5,vy:1,life:8,ml:8,sz:1,color:b.color});
    }else if(s==='tool'){
      // TOOLS: Purple spinning shuriken with diamond spark particles
      ctx.save();ctx.translate(b.x,b.y+b.h/2);ctx.rotate(gt*0.2);
      ctx.fillStyle=b.color;
      for(let i=0;i<4;i++){ctx.rotate(Math.PI/2);ctx.fillRect(-1,-5,2,5)}
      ctx.restore();
      ctx.fillStyle='#DDB8FF';ctx.fillRect(b.x-1,b.y+b.h/2-1,2,2);
      // Diamond sparks shed from rotation
      if(canSpawnParticles&&gt%3===0){
        const sa=gt*0.2+Math.random()*Math.PI;
        particles.push({x:b.x+Math.cos(sa)*4,y:b.y+b.h/2+Math.sin(sa)*4,
          vx:Math.cos(sa)*1.5,vy:Math.sin(sa)*1.5,life:10,ml:10,sz:1.5,color:'#DDB8FF',diamond:true});
      }
      // Homing tracking thread
      if(b.homing&&b._target){
        ctx.save();ctx.strokeStyle=C.gold;ctx.lineWidth=1;ctx.globalAlpha=0.3;
        ctx.setLineDash([3,3]);
        ctx.beginPath();ctx.moveTo(b.x,b.y+b.h/2);
        if(b._target.alive){ctx.lineTo(b._target.x,b._target.y);ctx.stroke()}
        ctx.setLineDash([]);ctx.restore();
      }
    }else if(s==='rail'){
      // THINKING T1: Golden bolt with lingering path glow
      ctx.fillStyle=b.color;ctx.globalAlpha=0.15;ctx.fillRect(b.x-1,b.y,2,GH-b.y);ctx.globalAlpha=1;
      ctx.fillStyle=b.color;ctx.globalAlpha=0.25;ctx.fillRect(b.x-6,b.y-2,12,b.h+4);ctx.globalAlpha=1;
      ctx.fillStyle=b.color;ctx.fillRect(b.x-3,b.y,6,b.h);
      ctx.fillStyle='#FFF';ctx.fillRect(b.x-1,b.y+1,2,b.h-2);
      // Spark shower at tip
      if(canSpawnParticles&&gt%4===0)particles.push({x:b.x+(Math.random()-0.5)*4,y:b.y,vx:(Math.random()-0.5)*1.5,vy:-2-Math.random(),life:10,ml:10,sz:1.5,color:C.gold});
    }else if(s==='beam'){
      // THINKING T2: Wide beam with pulsing concentric rings
      ctx.fillStyle=b.color;ctx.globalAlpha=0.12;ctx.fillRect(b.x-10,b.y-4,20,b.h+8);ctx.globalAlpha=1;
      ctx.fillStyle=b.color;ctx.fillRect(b.x-b.w/2,b.y,b.w,b.h);
      ctx.fillStyle='#FFF';ctx.fillRect(b.x-2,b.y+2,4,b.h-4);
      // Concentric rings traveling down beam
      ctx.strokeStyle=C.gold;ctx.lineWidth=1;
      for(let i=0;i<3;i++){
        const ry=b.y+(gt*3+i*12)%b.h;
        ctx.globalAlpha=0.2;
        ctx.beginPath();ctx.arc(b.x,ry,b.w/2+3+Math.sin(gt*0.2+i)*2,0,Math.PI*2);ctx.stroke();
      }
      ctx.globalAlpha=1;
      // Spark shower
      if(canSpawnParticles&&gt%4===0)particles.push({x:b.x+(Math.random()-0.5)*8,y:b.y,vx:(Math.random()-0.5)*2,vy:-2,life:8,ml:8,sz:2,color:b.color});
    }else if(s==='column'){
      // THINKING T3: Full-screen column with scan lines + CRT afterburn
      ctx.fillStyle=b.color;ctx.globalAlpha=0.08;ctx.fillRect(b.x-18,0,36,GH);
      ctx.globalAlpha=0.25;ctx.fillRect(b.x-b.w/2,0,b.w,GH);
      ctx.fillStyle='#FFF';ctx.globalAlpha=0.5;ctx.fillRect(b.x-3,0,6,GH);
      // Horizontal scan lines sweeping through
      for(let i=0;i<5;i++){
        const sy=(gt*8+i*GH/5)%GH;
        ctx.fillStyle=C.gold;ctx.globalAlpha=0.15;ctx.fillRect(b.x-b.w/2-2,sy,b.w+4,2);
      }
      ctx.globalAlpha=1;
      // CRT phosphor afterburn (faint gold glow persists)
      if(b.life<=5){
        ctx.fillStyle=C.gold;ctx.globalAlpha=b.life/5*0.08;ctx.fillRect(b.x-b.w/2-4,0,b.w+8,GH);ctx.globalAlpha=1;
      }
    }else if(s==='yolo'){
      // YOLO: Wobbly unstable shot shedding random debris
      const wobble=Math.sin(gt*0.5)*3;
      ctx.fillStyle=b.color;ctx.globalAlpha=0.25;
      ctx.fillRect(b.x-b.w+wobble,b.y-3,b.w*2,b.h+6);
      ctx.globalAlpha=1;ctx.fillStyle=C.accent;ctx.fillRect(b.x-b.w/2+wobble,b.y,b.w,b.h);
      ctx.fillStyle='#FFF';ctx.fillRect(b.x-3+wobble,b.y+2,6,b.h-4);
      ctx.fillStyle='#FFF';ctx.globalAlpha=0.4+Math.sin(gt*0.4)*0.3;
      ctx.font='5px "Press Start 2P"';ctx.textAlign='center';
      ctx.fillText('Y',b.x+wobble,b.y+8);ctx.fillText('O',b.x+wobble,b.y+14);
      // Shed unstable debris particles
      if(canSpawnParticles&&gt%4===0)particles.push({x:b.x+wobble+(Math.random()-0.5)*b.w,y:b.y+(Math.random()*b.h),
        vx:(Math.random()-0.5)*3,vy:(Math.random()-0.5)*2,life:6+Math.random()*6,ml:12,sz:1+Math.random()*2,color:Math.random()>0.5?C.red:C.accent});
    }else if(s==='storm'){
      // Fusion BURST FUNCTIONS: pink with cyan afterimage ribbon
      for(let i=2;i>0;i--){
        ctx.fillStyle=b.color;ctx.globalAlpha=0.15*i/2;
        ctx.fillRect(b.x-1,b.y+b.h*i*0.5,3,b.h*0.7);
      }
      ctx.globalAlpha=1;ctx.fillStyle=b.color;ctx.fillRect(b.x-2,b.y,4,b.h);
      ctx.fillStyle='#FFF';ctx.fillRect(b.x-1,b.y+1,2,b.h-2);
    }else if(s==='laser'){
      // Fusion UNHINGED REASONING: thick beam that wobbles with unstable sparks
      const lWob=Math.sin(gt*0.3)*2;
      ctx.fillStyle=b.color;ctx.globalAlpha=0.08;ctx.fillRect(b.x-18+lWob,b.y-4,36,b.h+8);
      ctx.globalAlpha=0.35;ctx.fillRect(b.x-b.w/2+lWob,b.y,b.w,b.h);
      ctx.fillStyle='#FFF';ctx.globalAlpha=0.7;ctx.fillRect(b.x-4+lWob,b.y+2,8,b.h-4);ctx.globalAlpha=1;
      // Unstable sparks
      if(canSpawnParticles&&gt%4===0){
        for(let i=0;i<2;i++)particles.push({x:b.x+lWob+(Math.random()-0.5)*b.w,y:b.y+Math.random()*b.h,
          vx:(Math.random()-0.5)*4,vy:(Math.random()-0.5)*3,life:8,ml:8,sz:2,color:Math.random()>0.5?'#FFA500':'#FFF'});
      }
    }else if(s==='rapidpierce'){
      // Fusion SPEED READ: fast cyan with long piercing trail
      ctx.fillStyle=b.color;ctx.globalAlpha=0.1;ctx.fillRect(b.x-1,b.y,2,GH-b.y);
      ctx.globalAlpha=1;ctx.fillStyle=b.color;ctx.fillRect(b.x-b.w/2,b.y,b.w,b.h);
      ctx.fillStyle='#FFF';ctx.fillRect(b.x-1,b.y,2,b.h);
    }else if(s==='mirv'){
      // Fusion MIRV: pulsing orb about to split
      const pulse=Math.sin(gt*0.3)*2;
      ctx.fillStyle=b.color;ctx.globalAlpha=0.25;
      ctx.beginPath();ctx.arc(b.x,b.y+b.h/2,b.w/2+5+pulse,0,Math.PI*2);ctx.fill();
      ctx.globalAlpha=1;ctx.fillStyle=b.color;
      ctx.beginPath();ctx.arc(b.x,b.y+b.h/2,b.w/2,0,Math.PI*2);ctx.fill();
      ctx.fillStyle='#FFF';ctx.beginPath();ctx.arc(b.x,b.y+b.h/2,3,0,Math.PI*2);ctx.fill();
      // Warning lines radiating out
      ctx.strokeStyle=b.color;ctx.lineWidth=1;ctx.globalAlpha=0.2;
      for(let i=0;i<6;i++){
        const ra=gt*0.05+i*Math.PI/3;
        ctx.beginPath();ctx.moveTo(b.x+Math.cos(ra)*b.w/2,b.y+b.h/2+Math.sin(ra)*b.w/2);
        ctx.lineTo(b.x+Math.cos(ra)*(b.w/2+8+pulse),b.y+b.h/2+Math.sin(ra)*(b.w/2+8+pulse));
        ctx.stroke();
      }
      ctx.globalAlpha=1;
    }else if(s==='charge'){
      // CHARGE SHOT: bright bolt with expanding glow
      const glow=b.w*1.5;
      ctx.fillStyle=b.color;ctx.globalAlpha=0.15;
      ctx.beginPath();ctx.arc(b.x,b.y+b.h/2,glow,0,Math.PI*2);ctx.fill();
      ctx.globalAlpha=0.3;ctx.fillRect(b.x-1,b.y,2,GH-b.y); // Trailing line
      ctx.globalAlpha=1;
      ctx.fillStyle=b.color;ctx.fillRect(b.x-b.w/2,b.y,b.w,b.h);
      ctx.fillStyle='#FFF';ctx.fillRect(b.x-2,b.y+2,4,b.h-4);
      drawClaudeStar(b.x,b.y,b.w*0.4,b.color,0.8);
      if(canSpawnParticles&&gt%4===0)particles.push({x:b.x+(Math.random()-0.5)*b.w,y:b.y+b.h,
        vx:(Math.random()-0.5)*2,vy:1+Math.random(),life:10,ml:10,sz:2,color:b.color});
    }else{
      // DEFAULT: Claude sparkle with warm-orange trailing particles
      drawClaudeStar(b.x,b.y+b.h/2,4,C.claudeOrange,0.9);
      ctx.fillStyle=C.cream;ctx.fillRect(b.x-1,b.y+2,2,b.h-4);
      // Orange particle trail
      if(canSpawnParticles&&gt%3===0)particles.push({x:b.x+(Math.random()-0.5)*3,y:b.y+b.h,
        vx:(Math.random()-0.5)*0.5,vy:0.5+Math.random(),life:8,ml:8,sz:1.5,color:C.claudeOrange});
    }
  }
  // Enemy bullets — varied by type
  ctx.font='7px "Press Start 2P"';ctx.textAlign='center'; // Set once for all enemy bullets
  for(let ebi=0;ebi<eBullets.length;ebi++){
    const b=eBullets[ebi];
    const et=b.etype||0;
    ctx.save();ctx.translate(b.x,b.y+b.h/2);
    if(b.decoy){
      // Hallucination decoy: flickering glitchy green
      ctx.globalAlpha=0.4+Math.sin(gt*0.5+b.x)*0.3;
      ctx.fillStyle=C.hallucGreen;ctx.fillRect(-3,-5,6,10);
      ctx.fillStyle='#88FF88';ctx.fillRect(-1,-3,2,6);
      if(((gt*7+b.x*3|0)&0xFF)>178){ctx.fillRect(-5+(((gt*11+b.y*5|0)&0xFF)%10),-4,3,2)}
    }else if(et===0){
      // Green hallucination enemy: glitchy question mark
      ctx.fillStyle=C.hallucGreen;ctx.globalAlpha=0.8;
      ctx.fillRect(-3,-5,6,10);
      ctx.fillStyle='#AAFFAA';
      ctx.fillText('?',0,3);
    }else if(et===1){
      // Purple injector enemy: code bracket
      ctx.fillStyle=C.injectPurple;ctx.fillRect(-3,-5,6,10);
      ctx.fillStyle='#DD88FF';
      ctx.fillText('>',0,3);
    }else if(et===2){
      // Red alignment enemy: spinning orb
      ctx.fillStyle=C.jailRed;
      ctx.beginPath();ctx.arc(0,0,4,0,Math.PI*2);ctx.fill();
      ctx.strokeStyle='#FF8888';ctx.lineWidth=1;
      ctx.beginPath();ctx.arc(0,0,5,gt*0.15,(gt*0.15)+Math.PI);ctx.stroke();
    }else if(et===10){
      // Hallucination boss: scatter shot — flickering green orbs
      const flicker=Math.sin(gt*0.3+b.y)*0.3;
      ctx.globalAlpha=0.6+flicker;
      ctx.fillStyle=C.hallucGreen;
      ctx.beginPath();ctx.arc(0,0,4,0,Math.PI*2);ctx.fill();
      ctx.fillStyle='#FFF';ctx.beginPath();ctx.arc(-1,-1,1.5,0,Math.PI*2);ctx.fill();
    }else if(et===11){
      // Injector boss: purple syringe
      ctx.fillStyle='#DD88FF';ctx.fillRect(-2,-6,4,12);
      ctx.fillStyle=C.injectPurple;ctx.fillRect(-3,-7,6,3);
      ctx.fillStyle='#FFF';ctx.fillRect(-1,-3,2,6);
    }else if(et===12){
      // Alignment boss: spinning ring
      ctx.strokeStyle=C.jailRed;ctx.lineWidth=2;
      ctx.beginPath();ctx.arc(0,0,5,0,Math.PI*2);ctx.stroke();
      ctx.fillStyle='#FF8888';
      const ra=gt*0.1;
      ctx.fillRect(Math.cos(ra)*4-1,Math.sin(ra)*4-1,3,3);
    }else{
      // Default fallback
      ctx.fillStyle='#FF3333';ctx.fillRect(-4,-5,8,10);
      ctx.fillStyle='#FF8888';
      ctx.fillText('>',0,3);
    }
    ctx.restore();
  }
  ctx.globalAlpha=1;
}

function updateBullets(){
  // Player bullets: in-place compaction (avoids .filter allocation per frame)
  let bw=0;
  for(let i=0;i<bullets.length;i++){
    const b=bullets[i];
    if(b._consumed){continue}
    b.x+=(b.vx||0);b.y+=b.vy;
    // Homing bullets (Tool Use T3)
    if(b.homing){
      let closest=null,closestDist2=40000; // 200^2 = 40000
      for(const e of enemies){
        if(!e.alive)continue;
        const dx=e.x-b.x,dy=e.y-b.y;
        const d2=dx*dx+dy*dy;
        if(d2<closestDist2){closestDist2=d2;closest=e}
      }
      // Also consider boss as a homing target
      if(boss&&boss.alive){
        const dx=boss.x-b.x,dy=boss.y-b.y;
        const d2=dx*dx+dy*dy;
        if(d2<closestDist2){closestDist2=d2;closest=boss}
      }
      if(closest){
        const dx=closest.x-b.x,dy=closest.y-b.y;
        const dist=Math.sqrt(dx*dx+dy*dy)||1;
        b.vx+=(dx/dist)*0.3;b.vy+=(dy/dist)*0.3;
        b._target=closest;
      }else{b._target=null}
    }
    // Column blast lifetime
    if(b.life!==undefined){b.life--;if(b.life<=0)continue}
    if(b.y>-20&&b.y<GH+20&&b.x>-20&&b.x<GW+20){bullets[bw++]=b}
  }
  bullets.length=bw;
  // eBullets: in-place compaction (avoids .filter allocation per frame)
  let ew=0;
  for(let i=0;i<eBullets.length;i++){
    const b=eBullets[i];
    if(b._consumed){continue}
    b.y+=(b.vy||0);b.x+=(b.vx||0);
    if(b.y>-20&&b.y<GH+20&&b.x>-20&&b.x<GW+20){eBullets[ew++]=b}
  }
  eBullets.length=ew;
}

// ═══════════════════════════════════════════════════════════════════════
// COLLISION
// ═══════════════════════════════════════════════════════════════════════
function hitbox(ax,ay,aw,ah,bx,by,bw,bh){
  return ax-aw/2<bx+bw/2&&ax+aw/2>bx-bw/2&&ay-ah/2<by+bh/2&&ay+ah/2>by-bh/2;
}

function doNuke(){
  sfx('nuke');nukeFlash=15;addShake(12);haptic(100);
  let nukeScore=0;
  for(const e of enemies){
    if(!e.alive)continue;e.alive=false;nukeScore+=(e.type+1)*50;enemyDeathEffect(e);lifetimeStats.kills++;
  }
  if(boss&&boss.alive){
    const dmg=Math.min(boss.hp,Math.floor(boss.maxHp/3)+1);
    boss.hp-=dmg;boss.fl=6;nukeScore+=dmg*50;
    if(boss.hp<=0){
      boss.alive=false;nukeScore+=1000;sfx('killboss');
      boom(boss.x,boss.y,BOSS_COLORS[boss.btype],32);boom(boss.x,boss.y,'#FF8888',20);
      boomRing(boss.x,boss.y,C.red,120);
      popup(boss.x,boss.y-40,BOSS_NAMES[boss.btype]+' DOWN!',BOSS_COLORS[boss.btype],true);
      spawnPU(boss.x-20,boss.y);spawnPU(boss.x+20,boss.y);
      contextWindow=Math.min(100,contextWindow+20);freezeFrames=5;
      controlInverted=false;controlInvertTimer=0;
      hudScramble=false;hudScrambleTimer=0;
    }
  }
  score+=nukeScore;
  // Convert all bullets to tokens
  for(const b of eBullets){
    scoreTokens.push({x:b.x,y:b.y+b.h/2,vx:(Math.random()-0.5)*4,vy:-3-Math.random()*2,
      life:120,pts:25,pulse:Math.random()*6});
  }
  eBullets=[];
  boomRing(player.x,player.y,C.red,200);
  popup(GW/2,GH/2-40,'NUKE! +'+nukeScore,C.red,true);
}

function checkCollisions(){
  if(!player)return;

  // Bullets -> Enemies
  for(let bi=bullets.length-1;bi>=0;bi--){
    const b=bullets[bi];if(!b||b._consumed)continue;
    for(let ei=0;ei<enemies.length;ei++){
      const e=enemies[ei];
      if(!e.alive)continue;
      if(b.pierce&&b._hitSet&&b._hitSet.has(e))continue;
      if(hitbox(b.x,b.isColumn?GH/2:b.y+b.h/2,b.w,b.isColumn?GH:b.h,e.x,e.y,e.w,e.h)){
        const dmg=b.dmg||1;
        e.hp-=dmg;e.fl=4;totalHits++;
        if(b.pierce){if(!b._hitSet)b._hitSet=new Set();b._hitSet.add(e)}
        if(!b.pierce){
          // MIRV split on hit
          if(b.style==='mirv'){
            for(let a=0;a<6;a++){
              const ang=-0.6+a*0.24;
              bullets.push({x:b.x,y:b.y,vy:-6*Math.cos(ang),vx:6*Math.sin(ang),w:5,h:8,dmg:1,
                style:'storm',color:'#FF88FF'});
            }
          }
          // Explosive splash
          if(b.explosive){
            boom(e.x,e.y,C.red,16);addShake(6);
            // Cross pattern explosion
            for(let d=0;d<4;d++){
              const ang=d*Math.PI/2;
              for(let j=0;j<3;j++){
                particles.push({x:e.x,y:e.y,vx:Math.cos(ang)*(3+j*2),vy:Math.sin(ang)*(3+j*2),
                  life:12+j*4,ml:20,sz:3-j*0.5,color:j===0?'#FFF':C.accent});
              }
            }
            // Expanding ring
            boomRing(e.x,e.y,C.red,40);
            for(let e2i=0;e2i<enemies.length;e2i++){
              const e2=enemies[e2i];
              if(!e2.alive||e2===e)continue;
              const d=Math.sqrt((e2.x-e.x)**2+(e2.y-e.y)**2);
              if(d<60){
                e2.hp--;e2.fl=3;
                if(e2.hp<=0){
                  e2.alive=false;enemyDeathEffect(e2);
                  bulletCancel(e2.x,e2.y,50);
                  combo++;comboTimer=Math.min(180, 90 + Math.floor(combo/5)*15);if(combo>maxCombo)maxCombo=combo;
                  if(combo>waveMaxCombo)waveMaxCombo=combo;
                  lifetimeStats.kills++;
                  if(inDangerZone)waveDangerKills++;
                  contextWindow=Math.min(100,contextWindow+3);
                  const splashPts=(e2.type+1)*75;score+=splashPts;
                  popup(e2.x,e2.y-20,'+'+splashPts,C.accent);
                  if(Math.random()<0.08)spawnPU(e2.x,e2.y);
                }
              }
            }
          }
          // Cluster split
          if(b.cluster){
            for(let i=0;i<8;i++){
              const ang=Math.PI*2/8*i;
              bullets.push({x:b.x,y:b.y,vy:Math.sin(ang)*5-2,vx:Math.cos(ang)*5,w:4,h:6,dmg:1,
                style:'storm',color:C.red,life:30});
            }
          }
          b._consumed=true;
        }
        if(e.hp<=0){
          e.alive=false;combo++;
          // Scale combo timer: base 90, +15 per 5-combo tier, capped at 180 (3 seconds)
          comboTimer=Math.min(180, 90 + Math.floor(combo/5)*15);
          if(combo>maxCombo)maxCombo=combo;
          if(combo>waveMaxCombo)waveMaxCombo=combo;
          contextWindow=Math.min(100,contextWindow+5);
          const ctxMult=1+Math.floor(contextWindow/25)*0.5;
          const mult=(combo>=10?4:combo>=5?3:combo>=3?2:1);
          const dangerMul=inDangerZone?1.5:1;
          const ocMul=overclocked?1.25:1;
          const basePts=(e.type+1)*100;
          const pathMul=(!isBonusWave&&pathMods.scoreMul)||1;
          const pts=Math.round(basePts*mult*ctxMult*dangerMul*ocMul*pathMul*(fullContextActive?2:1));
          lifetimeStats.kills++;
          if(inDangerZone)waveDangerKills++;
          score+=pts;
          if(e.type===2)sfx('killboss');else sfx('kill');
          enemyDeathEffect(e);
          // Bullet cancel — nearby enemy bullets become score tokens
          const cancelR=60+(combo>=5?30:0)+(e.type*15);
          bulletCancel(e.x,e.y,cancelR);
          if(e.type>=1)freezeFrames=e.type===2?3:2; // Impact freeze
          popup(e.x,e.y-20,'+'+pts,mult>1?C.gold:C.accent);
          if(mult>1){sfx('combo');popup(e.x,e.y-40,mult+'x COMBO',C.gold,true)}
          // Claude personality quip on combos
          if(gt-lastQuipGt>120){
            const eligible=CLAUDE_QUIPS_COMBO.filter(q=>combo>=q[0]&&combo<q[0]+3);
            if(eligible.length>0){
              const q=eligible[Math.random()*eligible.length|0];
              popup(GW/2,GH-120,'// '+q[1],C.dim);
              lastQuipGt=gt;
            }
          }
          if(Math.random()<0.35)popup(e.x,e.y-55,TASKS[Math.random()*TASKS.length|0],C.dim);
          const dropChance=e.bonusDrop?0.5:e.eliteDrop?1.0:(waveModifier&&waveModifier.id==='loot'?0.28:0.14);
          if(Math.random()<dropChance)spawnPU(e.x,e.y);
          addShake(e.type===2?6:4);
        }else{sfx('hit');addShake(2)}
        break;
      }
    }
    // Bullets -> Boss
    if(!b._consumed&&boss&&boss.alive){
      const b2=b;
      // Check shield nodes first (type 2)
      if(boss.btype===2&&boss.shieldActive){
        let hitNode=false;
        for(const n of boss.shieldNodes){
          if(!n.alive)continue;
          const nx=boss.x+Math.cos(n.angle)*n.dist;
          const ny=boss.y+Math.sin(n.angle)*n.dist;
          if(hitbox(b2.x,b2.isColumn?GH/2:b2.y+b2.h/2,b2.w,b2.isColumn?GH:b2.h,nx,ny,18,18)){
            n.hp-=(b2.dmg||1);if(n.hp<=0){n.alive=false;boom(nx,ny,C.jailRed,12);sfx('kill');score+=200;popup(nx,ny-15,'+200 NODE',C.gold)}
            else{sfx('hit')}
            b2._consumed=true; // Always consume on shield node hit (even pierce)
            if(b2.pierce){boom(nx,ny,'#4FC3F7',6);popup(nx,ny-25,'BLOCKED',C.dim)}
            hitNode=true;break;
          }
        }
        if(hitNode)continue;
        // Shield blocks hits to main body (including pierce)
        if(boss.shieldNodes.some(n=>n.alive)){
          if(hitbox(b2.x,b2.isColumn?GH/2:b2.y+b2.h/2,b2.w,b2.isColumn?GH:b2.h,boss.x,boss.y,boss.w,boss.h)){
            b2._consumed=true; // Shield blocks everything
            if(!boss._shieldPopCD||gt-boss._shieldPopCD>30){
              popup(boss.x,boss.y-40,'SHIELDED!',C.dim);
              boss._shieldPopCD=gt;
            }
            continue;
          }
        }
      }
      if(hitbox(b2.x,b2.isColumn?GH/2:b2.y+b2.h/2,b2.w,b2.isColumn?GH:b2.h,boss.x,boss.y,boss.w,boss.h)){
        if(!(b2.pierce&&b2._hitBoss)){
        // Not already hit boss — apply damage
        if(b2.pierce)b2._hitBoss=true;
        boss.hp-=(b2.dmg||1);boss.fl=3;totalHits++;
        if(!b2.pierce)b2._consumed=true;
        if(boss.hp<=0){
          boss.alive=false;
          const pts=2000+wave*500;score+=pts;
          sfx('killboss');addShake(15);freezeFrames=5;haptic(80);
          boom(boss.x,boss.y,BOSS_COLORS[boss.btype],40);
          boom(boss.x,boss.y,'#FF8888',24);
          boomRing(boss.x,boss.y,C.red,120);
          popup(boss.x,boss.y-40,BOSS_NAMES[boss.btype]+' DOWN! +'+pts,BOSS_COLORS[boss.btype],true);
          // Claude quip on boss clear
          const bcq=CLAUDE_QUIPS_BOSSCLEAR[Math.random()*CLAUDE_QUIPS_BOSSCLEAR.length|0];
          setTimeout(()=>{if(state==='playing')popup(GW/2,GH/2+40,'// '+bcq,C.dim)},500);
          spawnPU(boss.x-20,boss.y);spawnPU(boss.x+20,boss.y);
          contextWindow=Math.min(100,contextWindow+20);
          // Clear boss effects
          controlInverted=false;controlInvertTimer=0;
          hudScramble=false;hudScrambleTimer=0;
        }else{
          sfx('hit');addShake(2);
          if(!boss.rageTriggered&&boss.hp<=Math.floor(boss.maxHp*0.3)){
            boss.rageTriggered=true;boss.fireRate=Math.max(16,boss.fireRate-6);
            popup(boss.x,boss.y-50,'⚠ BOSS ENRAGED! ⚠',C.red,true);
            addShake(10);freezeFrames=8;haptic(120);
            // Rage flash — red screen pulse
            rageFlash=12;
            // Rage burst particles
            for(let i=0;i<24;i++){
              const a=Math.PI*2/24*i;
              particles.push({x:boss.x+Math.cos(a)*30,y:boss.y+Math.sin(a)*30,
                vx:Math.cos(a)*5,vy:Math.sin(a)*5,life:30,ml:30,sz:4,color:C.red});
            }
          }
        }
        }
      }
    }
  }

  // Graze detection
  if(player.inv<=0){
    for(let gi=0;gi<eBullets.length;gi++){
      const b=eBullets[gi];
      if(b._consumed)continue;
      const dx=b.x-player.x,dy=(b.y+b.h/2)-player.y;
      const dist=Math.sqrt(dx*dx+dy*dy);
      if(dist<player.w*0.8&&dist>player.w*0.35&&!b.grazed){
        b.grazed=true;b._grazeFrame=gt;grazeCount++;waveGrazes++;
        const grazePts=Math.round(50*tauntGrazeMul*(inDangerZone?1.5:1));
        score+=grazePts;sfx('graze');
        const grazeLabel=tauntGrazeMul>1?'PROVOKE GRAZE +'+grazePts:'ALIGNED +'+grazePts;
        popup(player.x+(Math.random()-0.5)*20,player.y-30,grazeLabel,
          tauntGrazeMul>1?C.accent:C.shieldBlue);
        // Graze pulse ring
        for(let gr=0;gr<16;gr++){
          const ga=Math.PI*2/16*gr;
          particles.push({x:player.x+Math.cos(ga)*18,y:player.y+Math.sin(ga)*18,
            vx:Math.cos(ga)*2.5,vy:Math.sin(ga)*2.5,life:14,ml:14,sz:2,color:C.shieldBlue});
        }
        contextWindow=Math.min(100,contextWindow+2);
      }
    }
  }

  // Enemy bullets -> Player
  if(player.inv<=0){
    for(let i=eBullets.length-1;i>=0;i--){
      const b=eBullets[i];
      if(b._consumed)continue;
      // Skip bullets that were just grazed this frame (prevents graze + hit on same frame)
      if(b._grazeFrame===gt)continue;
      if(hitbox(b.x,b.y+b.h/2,b.w,b.h,player.x,player.y,player.w-8,player.h-4)){
        b._consumed=true;
        if(player.shield){
          player.shield=false;player.shieldTime=0;
          sfx('shield');boom(player.x,player.y,C.shieldBlue,12);
          popup(player.x,player.y-30,'RLHF BLOCKED!',C.shieldBlue);addShake(4);
        }else{hitPlayer()}
        break;
      }
    }
  }

  // Power-ups -> Player (in-place compaction)
  let puw2=0;
  for(let i=0;i<powerUps.length;i++){
    const pu=powerUps[i];
    if(hitbox(pu.x,pu.y,pu.w,pu.h,player.x,player.y,player.w+12,player.h+12)){
      applyWeaponPickup(pu.type);
      puUsed[pu.type]=(puUsed[pu.type]||0)+1;
      wavePUGrabs++;
      boom(pu.x,pu.y,pu.color,10);addShake(3);
    }else{powerUps[puw2++]=pu}
  }
  powerUps.length=puw2;

  // Wave clear
  let allDead=true;for(let i=0;i<enemies.length;i++){if(enemies[i].alive){allDead=false;break}}
  const bossGone=!boss||!boss.alive;
  if(allDead&&bossGone&&waveTransTimer<=0){
    // Convert all remaining enemy bullets to score tokens — satisfying wave-clear cascade
    for(const b of eBullets){
      scoreTokens.push({x:b.x,y:b.y+b.h/2,vx:(Math.random()-0.5)*3,vy:-2-Math.random()*2,
        life:120,pts:25,pulse:Math.random()*6});
      particles.push({x:b.x,y:b.y,vx:(Math.random()-0.5)*1,vy:(Math.random()-0.5)*1,
        life:8,ml:8,sz:1.5,color:C.gold});
    }
    eBullets=[];
    // Dramatic wave clear
    slowmoTimer=Math.max(slowmoTimer,18); // Brief slow-mo
    waveClearStamp=60; // Stamp animation timer
    sfx('waveclear');
    // Claude wave-clear quip
    const wcq=CLAUDE_QUIPS_WAVECLEAR[Math.random()*CLAUDE_QUIPS_WAVECLEAR.length|0];
    popup(GW/2,GH/2+30,'// '+wcq,C.dim);
    // Shop after wave 5+ (not bonus waves, not pre-boss, not boss)
    const showShop=wave>=5&&!isBonusWave&&wave%5!==4&&wave%5!==0;
    waveTransTimer=showShop?180:130;
    shopAttempted=false;
    for(let i=0;i<20;i++){
      const a=Math.random()*Math.PI*2;
      particles.push({x:GW/2+Math.cos(a)*80,y:GH/2+Math.sin(a)*80,
        vx:Math.cos(a)*3,vy:Math.sin(a)*3,life:50,ml:50,sz:3,
        color:[C.claudeOrange,C.gold,C.cyan,C.green][i%4]});
    }
    sfx('wave');
    // Check wave challenge
    if(waveChallenge&&!waveChallengeComplete&&waveChallenge.check()){
      waveChallengeComplete=true;
      score+=waveChallenge.pts;
      sfx('tierup');
      popup(GW/2,GH/2-80,'CHALLENGE: '+waveChallenge.text+' +'+waveChallenge.pts,C.gold,true);
    }
  }

  // Full Context activation
  if(contextWindow>=100&&!fullContextActive){
    fullContextActive=true;fullContextTimer=FULL_CTX_DUR;contextWindow=0;
    sfx('fullctx');
    popup(GW/2,GH/2-80,'Claude is thinking...',C.dim);
    popup(GW/2,GH/2-60,'★ FULL CONTEXT MODE ★',C.gold,true);
    boomRing(player.x,player.y,C.gold,100);
    player.inv=Math.max(player.inv,30); // Brief invincibility
  }

  // Compact consumed bullets (deferred from collision loop to avoid O(n) splices)
  let bw=0;
  for(let i=0;i<bullets.length;i++){if(!bullets[i]._consumed)bullets[bw++]=bullets[i]}
  bullets.length=bw;

  // Extra life every 10k
  if(score>=nextLifeAt){
    const maxLives=diffSettings[difficulty].lives+3;
    if(lives<maxLives){
      lives++;sfx('powerup');
      popup(player.x,player.y-50,'EXTRA LIFE!',C.green,true);
      boom(player.x,player.y,C.green,16);
    }else{score+=2000;popup(player.x,player.y-50,'MAX LIVES +2000',C.gold,true)}
    nextLifeAt+=10000;
  }
}

function hitPlayer(){
  lives--;player.inv=90;sfx('damage');haptic(50);
  waveNoDamage=false;
  // Claude quip on damage
  if(gt-lastQuipGt>90){
    const q=CLAUDE_QUIPS_DAMAGE[Math.random()*CLAUDE_QUIPS_DAMAGE.length|0];
    popup(player.x+(Math.random()-0.5)*60,player.y-60,'// '+q,C.dim);
    lastQuipGt=gt;
  }
  boom(player.x,player.y,C.cream,20);addShake(10);
  combo=Math.floor(combo/2);comboTimer=combo>0?60:0;
  contextWindow=Math.max(0,contextWindow-30);
  // Lose a weapon tier on hit
  if(player.fusion){
    // Retain first weapon at T1 when fusion breaks from damage
    const firstWeapon=player.fusion.split('+')[0];
    player.fusion=null;player.fusionTimer=0;
    player.weapon=firstWeapon;player.weaponTier=1;player.puTime=240;player.puMax=240;
  }
  else if(player.weaponTier>1)player.weaponTier--;
  if(lives<=0)triggerGameOver();
}

function triggerGameOver(){
  if(state==='gameover')return;
  state='gameover';sfx('gameover');stopBGM();haptic(200);
  controlInverted=false;hudScramble=false;
  shopActive=false;
  scoreTokens=[]; // Clean up floating tokens
  eBullets=[]; // Clear enemy bullets
  bullets=[]; // Clear player bullets
  powerUps=[]; // Clear floating power-ups
  tauntActive=false;overclocked=false;overclockedGlow=0;
  fullContextActive=false;fullContextTimer=0;
  newHi=score>hi&&score>0;
  if(newHi){hi=score;try{localStorage.setItem('agentSwarmHi3',hi.toString())}catch(e){}}
  // Persistent stats
  lifetimeStats.tokens+=score;lifetimeStats.runs++;
  if(wave>lifetimeStats.bestWave[difficulty])lifetimeStats.bestWave[difficulty]=wave;
  try{localStorage.setItem('agentSwarmStats',JSON.stringify(lifetimeStats))}catch(e){}
}

function addShake(v){shake.i=Math.max(shake.i,v)}
function updateShake(){
  if(shake.i>0){shake.x=(Math.random()-0.5)*shake.i*2;shake.y=(Math.random()-0.5)*shake.i*2;shake.i*=0.82;if(shake.i<0.5)shake.i=0}
  else{shake.x=0;shake.y=0}
}

// ═══════════════════════════════════════════════════════════════════════
// SAFETY LAYER MAP
// ═══════════════════════════════════════════════════════════════════════
function generateMapGraph(){
  // Create a Slay-the-Spire style branching graph
  const rows=[];
  for(let r=0;r<6;r++){
    const nodes=[];
    for(let n=0;n<MAP_ROW_SIZES[r];n++){
      let type;
      if(r===0||r===5) type='standard';
      else{
        // Weighted random selection from node types
        const pool=[];
        for(const mn of MAP_NODES){for(let w=0;w<mn.weight;w++)pool.push(mn.id)}
        type=pool[Math.random()*pool.length|0];
        // Ensure at least one rest stop in rows 2-4
        if(r>=2&&r<=4&&n===0&&!rows.some(rw=>rw&&rw.nodes.some(nd=>nd.type==='rest'))){
          if(Math.random()<0.4)type='rest';
        }
      }
      nodes.push({type,connections:[],visited:false,reachable:false});
    }
    rows.push({nodes});
  }
  // Generate connections — each node connects to 1-3 nodes in next row
  for(let r=0;r<5;r++){
    const curr=rows[r].nodes;
    const next=rows[r+1].nodes;
    const cLen=curr.length,nLen=next.length;
    // Primary connections: map proportionally
    for(let n=0;n<cLen;n++){
      const center=nLen>1?(n/(cLen-1||1))*(nLen-1):0;
      const lo=Math.max(0,Math.floor(center-0.8));
      const hiIdx=Math.min(nLen-1,Math.ceil(center+0.8));
      for(let t=lo;t<=hiIdx;t++){
        if(!curr[n].connections.includes(t))curr[n].connections.push(t);
      }
      // Random extra connection for variety
      if(Math.random()<0.3&&nLen>2){
        const extra=Math.floor(Math.random()*nLen);
        if(!curr[n].connections.includes(extra)&&Math.abs(extra-center)<2.5)
          curr[n].connections.push(extra);
      }
    }
    // Ensure every next-row node has at least 1 incoming
    for(let t=0;t<nLen;t++){
      if(!curr.some(nd=>nd.connections.includes(t))){
        const nearest=Math.round((t/Math.max(1,nLen-1))*(cLen-1));
        curr[Math.min(cLen-1,Math.max(0,nearest))].connections.push(t);
      }
    }
  }
  // Mark start node
  rows[0].nodes[0].visited=true;rows[0].nodes[0].reachable=true;
  for(const c of rows[0].nodes[0].connections)rows[1].nodes[c].reachable=true;
  return{rows};
}

function getMapNodeDef(typeId){return MAP_NODES.find(n=>n.id===typeId)||MAP_NODES[0]}

function getMapNodeXY(row,col){
  // Calculate x,y position for a node in the branching graph
  const mapTop=90,mapBot=630;
  const rowH=(mapBot-mapTop)/5;
  const y=mapBot-row*rowH;
  const count=MAP_ROW_SIZES[row];
  const totalW=Math.min(count*130,500);
  const startX=(GW-totalW)/2+totalW/(count*2);
  const spacing=count>1?totalW/(count):0;
  const x=startX+col*spacing;
  return{x,y};
}

function resolveMysteryNode(){
  // Mystery: random outcome weighted toward interesting results
  const outcomes=[
    {label:'JACKPOT',desc:'+2 lives!',color:C.green,icon:'♥',effect:()=>{lives=Math.min(lives+2,diffSettings[difficulty].lives+3)}},
    {label:'OVERDRIVE',desc:'2× score this layer!',color:C.gold,icon:'★',effect:()=>{pathMods.scoreMul=2.0}},
    {label:'CURSED',desc:'Enemies +2 HP...',color:C.red,icon:'☠',effect:()=>{pathMods.hpBonus=2;pathMods.fireBonus=0.4}},
    {label:'GLITCH',desc:'Tiny + fast enemies',color:'#E040FB',icon:'⚡',effect:()=>{pathMods.tinyEnemies=true;pathMods.speedBoost=true}},
    {label:'NOTHING',desc:'The void stares back',color:C.dim,icon:'∅',effect:()=>{}},
    {label:'BOUNTY',desc:'1.5× score + heal',color:C.cyan,icon:'◆',effect:()=>{pathMods.scoreMul=1.5;lives=Math.min(lives+1,diffSettings[difficulty].lives+3)}},
    {label:'ARMORY',desc:'Start with T1 weapon',color:C.claudeOrange,icon:'▲',effect:()=>{
      if(player){const w=['streaming','tooluse','thinking','yolo'];const p2=w[Math.random()*w.length|0];
      player.weapon=p2;player.weaponTier=1;player.puTime=360;player.puMax=360;sfx('powerup')}}},
    {label:'FRAGILE',desc:'−1 life, 2× score',color:'#FF6666',icon:'✕',effect:()=>{lives=Math.max(1,lives-1);pathMods.scoreMul=2.0}},
  ];
  // Shuffle and pick 3 unique options
  for(let i=outcomes.length-1;i>0;i--){const j=Math.random()*(i+1)|0;[outcomes[i],outcomes[j]]=[outcomes[j],outcomes[i]]}
  return outcomes.slice(0,3);
}

function enterMap(){
  state='map';mapState='entering';mapTimer=0;mapSelected=-1;
  particles=[];popups=[];deadEnemies=[];scoreTokens=[];bullets=[];eBullets=[];
  pathMods={};mapMysteryResult=null;mapMysteryChoices=null;mapMysteryHover=-1;mapWeaponLabChoices=null;mapHoverNode=-1;
  const targetLayer=Math.min(Math.floor(wave/5),LAYERS.length-1);
  if(targetLayer>currentLayer){currentLayer=targetLayer;sfx('layerup')}
  sfx('mapopen');stopBGM();
  // Generate graph on first map visit; regenerate when exhausted; update reachability on subsequent
  if(!mapGraph||mapPlayerRow>=5){
    mapGraph=generateMapGraph();
    mapPlayerRow=0;
  }
  // Advance player row
  if(mapPlayerRow<5)mapPlayerRow++;
  // Build choices from reachable nodes in current row
  mapChoices=[];
  if(mapPlayerRow<6){
    const row=mapGraph.rows[mapPlayerRow];
    for(let n=0;n<row.nodes.length;n++){
      if(row.nodes[n].reachable)mapChoices.push(n);
    }
    // Safety fallback: if no nodes are reachable, make all nodes in this row reachable
    if(mapChoices.length===0){
      for(let n=0;n<row.nodes.length;n++){
        row.nodes[n].reachable=true;
        mapChoices.push(n);
      }
    }
  }
  // Generate star field
  mapStarField=[];
  for(let i=0;i<80;i++){
    mapStarField.push({x:Math.random()*GW,y:Math.random()*GH,
      sz:0.5+Math.random()*1.5,spd:0.1+Math.random()*0.3,
      bright:0.2+Math.random()*0.6,twinkleOff:Math.random()*Math.PI*2});
  }
  // Generate path particles
  mapPathParticles=[];
  for(let i=0;i<40;i++){
    mapPathParticles.push({
      fromRow:Math.floor(Math.random()*5),fromNode:0,toNode:0,
      t:Math.random(),spd:0.003+Math.random()*0.005,
      bright:0.3+Math.random()*0.4,sz:1+Math.random()*2
    });
    // Assign valid path
    const pp=mapPathParticles[mapPathParticles.length-1];
    const fr=pp.fromRow;
    const srcNodes=mapGraph.rows[fr].nodes;
    const srcIdx=Math.floor(Math.random()*srcNodes.length);
    pp.fromNode=srcIdx;
    const conns=srcNodes[srcIdx].connections;
    pp.toNode=conns.length?conns[Math.floor(Math.random()*conns.length)]:0;
  }
}

function selectMapPath(nodeIdx){
  if(mapState!=='choosing'||mapPlayerRow>=6)return;
  const row=mapGraph.rows[mapPlayerRow];
  if(!row.nodes[nodeIdx]||!row.nodes[nodeIdx].reachable)return;
  mapSelected=nodeIdx;mapState='exiting';mapTimer=0;
  sfx('mappick');
  // Mark visited
  row.nodes[nodeIdx].visited=true;
  // Update reachability for next row
  if(mapPlayerRow<5){
    const nextRow=mapGraph.rows[mapPlayerRow+1];
    // Clear old reachability
    for(const n of nextRow.nodes)n.reachable=false;
    // Set new reachability based on selected node's connections
    for(const c of row.nodes[nodeIdx].connections){
      nextRow.nodes[c].reachable=true;
    }
  }
  // Apply node effects
  const nodeDef=getMapNodeDef(row.nodes[nodeIdx].type);
  pathMods={...(nodeDef.mods||{})};
  // Special node handling
  if(pathMods.heal){
    const maxLives=diffSettings[difficulty].lives+3;
    lives=Math.min(lives+pathMods.heal,maxLives);
    delete pathMods.heal;
  }
  if(pathMods.permFireRate){
    permFireRateBonus+=pathMods.permFireRate;
    // Warn when approaching the 0.4 floor
    if(1-permFireRateBonus<=0.5){
      popup(GW/2,GH/2+40,'FIRE RATE NEAR MAXIMUM',C.dim);
    }
    delete pathMods.permFireRate;
  }
  if(row.nodes[nodeIdx].type==='mystery'){
    mapMysteryChoices=resolveMysteryNode();
    mapMysteryHover=-1;
    mapState='mystery';mapTimer=0;
    // Don't exit yet — wait for player to pick
  }
  if(row.nodes[nodeIdx].type==='weaponlab'){
    // Show weapon choice UI — player picks from 3 random T2 weapons
    const wpnTypes=['streaming','tooluse','thinking','yolo'];
    // Shuffle and pick 3
    for(let i=wpnTypes.length-1;i>0;i--){const j=Math.random()*(i+1)|0;[wpnTypes[i],wpnTypes[j]]=[wpnTypes[j],wpnTypes[i]]}
    mapWeaponLabChoices=wpnTypes.slice(0,3);
    mapMysteryHover=-1; // Reuse hover index
    mapState='weaponlab';mapTimer=0;
    // Don't exit yet — wait for player to pick
  }
}

function selectMysteryChoice(idx){
  if(mapState!=='mystery'||!mapMysteryChoices||idx<0||idx>=mapMysteryChoices.length)return;
  const choice=mapMysteryChoices[idx];
  mapMysteryResult=choice;
  choice.effect();
  sfx('powerup');
  mapState='exiting';mapTimer=0;
}

function selectWeaponLabChoice(idx){
  if(mapState!=='weaponlab'||!mapWeaponLabChoices||idx<0||idx>=mapWeaponLabChoices.length)return;
  const pick=mapWeaponLabChoices[idx];
  if(player){
    player.weapon=pick;player.weaponTier=2;player.puTime=480;player.puMax=480;
    player.fusion=null;player.fusionTimer=0;
    sfx('tierup');
    const td=WEAPON_TIERS[pick];
    popup(GW/2,GH/2+60,'T2 '+td.name[1]+'!',td.color,true);
  }
  mapWeaponLabChoices=pick; // Store chosen weapon for exit confirmation text
  sfx('shoppick');
  mapState='exiting';mapTimer=0;
}

function updateMap(){
  mapTimer++;
  // Stars
  for(const s of mapStarField){
    s.y+=s.spd;
    if(s.y>GH){s.y=0;s.x=Math.random()*GW}
  }
  // Path particles
  for(const pp of mapPathParticles){
    pp.t+=pp.spd;
    if(pp.t>1){
      pp.t=0;
      // Pick new random path
      const fr=Math.floor(Math.random()*5);
      pp.fromRow=fr;
      const srcNodes=mapGraph.rows[fr].nodes;
      const srcIdx=Math.floor(Math.random()*srcNodes.length);
      pp.fromNode=srcIdx;
      const conns=srcNodes[srcIdx].connections;
      pp.toNode=conns.length?conns[Math.floor(Math.random()*conns.length)]:0;
    }
  }
  if(mapState==='entering'&&mapTimer>60)mapState='choosing';
  if(mapState==='exiting'&&mapTimer>50){
    state='playing';
    wave++;showWaveBanner=true;waveBannerTimer=120;
    waveNumAlpha=1.0;
    terminalLog=getTerminalLog(wave);
    spawnWave(wave);
    startBGM();
  }
}

function drawMap(){
  ctx.fillStyle=C.bg;ctx.fillRect(0,0,GW,GH);
  drawGrid();

  // ── PARALLAX STAR FIELD ──
  for(const s of mapStarField){
    const twinkle=0.5+0.5*Math.sin(gt*0.05+s.twinkleOff);
    ctx.fillStyle='#FFF';ctx.globalAlpha=s.bright*twinkle*0.6;
    ctx.fillRect(s.x|0,s.y|0,s.sz,s.sz);
  }
  ctx.globalAlpha=1;

  const enterPct=mapState==='entering'?Math.min(1,mapTimer/50):1;
  const exitPct=mapState==='exiting'?1-Math.min(1,mapTimer/40):1;
  const alpha=enterPct*exitPct;
  ctx.globalAlpha=alpha;

  // ── TITLE ──
  txt('SAFETY ARCHITECTURE',GW/2,32,C.claudeOrange,14,'center',C.claudeOrange);
  drawClaudeStar(GW/2,52,6,C.claudeOrange,0.6);

  // ── LAYER LABELS (right side) ──
  for(let r=0;r<6;r++){
    const pos=getMapNodeXY(r,0);
    const layer=LAYERS[r];
    const isPast=r<mapPlayerRow;
    const isActive=r===mapPlayerRow&&mapState==='choosing';
    const isFuture=r>mapPlayerRow;
    ctx.globalAlpha=alpha*(isFuture?0.15:isPast?0.4:0.8);
    const lx=24;
    txt(layer.name,lx,pos.y+4,isPast?C.dim:layer.color,isPast?6:isActive?7:6,'left',isActive?layer.color:null);
    if(isPast)txt('✓',lx-10,pos.y+4,C.green,6,'left');
    if(isActive){
      ctx.globalAlpha=alpha*(0.4+0.3*Math.sin(gt*0.1));
      txt('►',lx-10,pos.y+4,layer.color,6,'left');
    }
  }

  // ── DRAW CONNECTIONS (paths between nodes) ──
  if(mapGraph){
    for(let r=0;r<5;r++){
      const srcRow=mapGraph.rows[r];
      for(let n=0;n<srcRow.nodes.length;n++){
        const node=srcRow.nodes[n];
        const from=getMapNodeXY(r,n);
        for(const c of node.connections){
          const to=getMapNodeXY(r+1,c);
          const targetNode=mapGraph.rows[r+1].nodes[c];
          // Determine path state
          const isVisited=node.visited&&targetNode.visited;
          const isReachable=r+1===mapPlayerRow&&targetNode.reachable&&mapState==='choosing';
          const isPastPath=r+1<mapPlayerRow;

          ctx.beginPath();
          // Curved bezier path
          const midY=(from.y+to.y)/2;
          ctx.moveTo(from.x,from.y-14);
          ctx.bezierCurveTo(from.x,midY,to.x,midY,to.x,to.y+14);

          if(isVisited){
            ctx.strokeStyle=LAYERS[r].color;ctx.lineWidth=3;
            ctx.globalAlpha=alpha*0.7;
            ctx.setLineDash([]);
          }else if(isReachable){
            ctx.strokeStyle=LAYERS[mapPlayerRow].color;ctx.lineWidth=2;
            ctx.globalAlpha=alpha*(0.3+0.2*Math.sin(gt*0.08));
            ctx.setLineDash([]);
          }else if(isPastPath){
            ctx.strokeStyle=C.dim;ctx.lineWidth=1;
            ctx.globalAlpha=alpha*0.15;
            ctx.setLineDash([]);
          }else{
            ctx.strokeStyle=C.dim;ctx.lineWidth=1;
            ctx.globalAlpha=alpha*0.08;
            ctx.setLineDash([4,6]);
          }
          ctx.stroke();
          ctx.setLineDash([]);
        }
      }
    }

    // ── ANIMATED PATH PARTICLES ──
    for(const pp of mapPathParticles){
      const from=getMapNodeXY(pp.fromRow,pp.fromNode);
      const to=getMapNodeXY(pp.fromRow+1,pp.toNode);
      const srcNode=mapGraph.rows[pp.fromRow].nodes[pp.fromNode];
      const isVisitedPath=srcNode.visited&&mapGraph.rows[pp.fromRow+1].nodes[pp.toNode].visited;
      if(!isVisitedPath&&pp.fromRow+1!==mapPlayerRow)continue; // Only animate relevant paths
      const midY=(from.y+to.y)/2;
      const t=pp.t;
      // Proper cubic bezier with intermediate control points for natural curve
      const mt=1-t;
      const cpx1=from.x,cpy1=from.y-14;
      const cpx2=from.x,cpy2=midY;
      const cpx3=to.x,cpy3=midY;
      const cpx4=to.x,cpy4=to.y+14;
      const px=mt*mt*mt*cpx1+3*mt*mt*t*cpx2+3*mt*t*t*cpx3+t*t*t*cpx4;
      const py=mt*mt*mt*cpy1+3*mt*mt*t*cpy2+3*mt*t*t*cpy3+t*t*t*cpy4;
      const layerColor=LAYERS[Math.min(pp.fromRow,5)].color;
      ctx.globalAlpha=alpha*pp.bright*(1-Math.abs(t-0.5)*2)*0.6;
      ctx.fillStyle=isVisitedPath?layerColor:'#FFFFFF';
      ctx.beginPath();ctx.arc(px,py,pp.sz,0,Math.PI*2);ctx.fill();
    }

    // ── DRAW NODES ──
    for(let r=0;r<6;r++){
      const row=mapGraph.rows[r];
      for(let n=0;n<row.nodes.length;n++){
        const node=row.nodes[n];
        const pos=getMapNodeXY(r,n);
        const nodeDef=getMapNodeDef(node.type);
        const isPast=r<mapPlayerRow;
        const isActive=r===mapPlayerRow&&mapState==='choosing';
        const isFuture=r>mapPlayerRow;
        const isReachable=node.reachable&&isActive;
        const isSelected=isActive&&mapSelected===n;
        const isHovered=isActive&&mapHoverNode===n&&node.reachable;
        const pulse=Math.sin(gt*0.1+n*1.5+r)*0.12;

        // Node glow for reachable
        if(isReachable&&!isSelected){
          const glowR=28+8*Math.sin(gt*0.08+n);
          ctx.globalAlpha=alpha*0.15;
          ctx.fillStyle=nodeDef.color;
          ctx.beginPath();ctx.arc(pos.x,pos.y,glowR,0,Math.PI*2);ctx.fill();
          ctx.globalAlpha=alpha*0.06;
          ctx.beginPath();ctx.arc(pos.x,pos.y,glowR*1.3,0,Math.PI*2);ctx.fill();
        }

        // Node circle
        const radius=isSelected?24:isHovered?22:isPast?14:isFuture?10:18;
        ctx.globalAlpha=alpha*(isFuture?0.15:isPast?0.4:isReachable?0.8+pulse:0.25);
        ctx.fillStyle=node.visited?nodeDef.color+'30':isReachable?'rgba(255,255,255,0.08)':'rgba(255,255,255,0.03)';
        ctx.beginPath();ctx.arc(pos.x,pos.y,radius,0,Math.PI*2);ctx.fill();

        // Border
        ctx.strokeStyle=node.visited?nodeDef.color:isReachable?nodeDef.color:C.dim;
        ctx.lineWidth=isSelected?3:isReachable?2:1;
        ctx.globalAlpha=alpha*(node.visited?0.7:isReachable?0.6+pulse:isFuture?0.08:0.2);
        ctx.beginPath();ctx.arc(pos.x,pos.y,radius,0,Math.PI*2);ctx.stroke();

        // Icon
        if(!isFuture||node.type!=='standard'){
          ctx.globalAlpha=alpha*(isFuture?0.12:isPast?0.35:isReachable?0.9:0.2);
          const iconSz=isSelected?14:isReachable?11:isPast?8:7;
          txt(nodeDef.icon,pos.x,pos.y+4,isSelected?'#FFF':nodeDef.color,iconSz,'center');
        }

        // Visited checkmark
        if(node.visited&&isPast){
          ctx.globalAlpha=alpha*0.6;
          txt('✓',pos.x+radius-2,pos.y-radius+4,C.green,6,'center');
        }

        // Labels for active/reachable nodes
        if(isReachable||isSelected){
          ctx.globalAlpha=alpha*(isSelected?1:isHovered?0.9:0.7);
          txt(nodeDef.label,pos.x,pos.y+radius+16,nodeDef.color,isSelected?8:7,'center',isSelected?nodeDef.color:null);
          desc(nodeDef.desc,pos.x,pos.y+radius+30,C.dim,13,'center');
        }
      }
    }

    // ── BOSS INDICATORS between layer boundaries ──
    for(let r=0;r<5;r++){
      const from=getMapNodeXY(r,0);
      const to=getMapNodeXY(r+1,0);
      const bossY=(from.y+to.y)/2;
      const isPast=r+1<=mapPlayerRow;
      ctx.globalAlpha=alpha*(isPast?0.2:r+1===mapPlayerRow?0.45:0.08);
      txt('◈',GW/2+160,bossY+4,isPast?C.dim:BOSS_COLORS[r%3],8,'center');
      ctx.globalAlpha=alpha*(isPast?0.15:r+1===mapPlayerRow?0.3:0.06);
      desc(BOSS_NAMES[r%3],GW/2+160,bossY+18,isPast?C.dim:BOSS_COLORS[r%3],11,'center');
    }
  }

  // ── LAYER ADVANCEMENT TEXT ──
  ctx.globalAlpha=alpha;
  if(mapState==='choosing'&&mapPlayerRow<6){
    const nextLayer=LAYERS[mapPlayerRow];
    if(nextLayer){
      divider(GW/2-200,660,400,nextLayer.color);
      txt('ENTERING: '+nextLayer.name+' LAYER',GW/2,680,nextLayer.color,9,'center',nextLayer.color);
      desc(nextLayer.desc.toUpperCase(),GW/2,698,C.dim,15,'center');
      const pa=0.4+Math.sin(gt*0.08)*0.3;
      ctx.globalAlpha=alpha*pa;
      txt('CHOOSE YOUR PATH',GW/2,722,C.tan,10,'center',C.tan);
      // Keyboard hint
      if(!isMobile&&mapChoices.length>0){
        ctx.globalAlpha=alpha*0.4;
        desc('PRESS 1-'+mapChoices.length+' OR CLICK A NODE',GW/2,740,C.dim,14,'center');
      }
    }
  }

  // ── MYSTERY CHOICE UI ──
  if(mapState==='mystery'&&mapMysteryChoices){
    const fadePct=Math.min(1,mapTimer/25);
    ctx.globalAlpha=alpha*fadePct;
    // Dimmed overlay
    ctx.fillStyle='rgba(0,0,0,0.6)';ctx.fillRect(0,0,GW,GH);
    // Title
    txt('? MYSTERY NODE ?',GW/2,180,'#E040FB',14,'center','#E040FB');
    desc('CHOOSE YOUR FATE',GW/2,205,C.dim,14,'center');
    // 3 choice cards
    for(let i=0;i<mapMysteryChoices.length;i++){
      const ch=mapMysteryChoices[i];
      const cx=GW/2+(i-1)*140;
      const cy=340;
      const hover=mapMysteryHover===i;
      const scale2=hover?1.05:1;
      ctx.save();ctx.translate(cx,cy);ctx.scale(scale2,scale2);
      // Card background
      ctx.fillStyle=hover?'rgba(255,255,255,0.12)':'rgba(255,255,255,0.05)';
      ctx.strokeStyle=ch.color;ctx.lineWidth=hover?3:1.5;
      ctx.beginPath();ctx.moveTo(-52+8,-70);ctx.lineTo(52-8,-70);ctx.quadraticCurveTo(52,-70,52,-70+8);
      ctx.lineTo(52,70-8);ctx.quadraticCurveTo(52,70,52-8,70);ctx.lineTo(-52+8,70);ctx.quadraticCurveTo(-52,70,-52,70-8);
      ctx.lineTo(-52,-70+8);ctx.quadraticCurveTo(-52,-70,-52+8,-70);ctx.closePath();ctx.fill();ctx.stroke();
      // Icon
      ctx.textAlign='center';ctx.textBaseline='middle';
      ctx.font='bold 28px monospace';ctx.fillStyle=ch.color;ctx.fillText(ch.icon||'?',0,-30);
      // Label
      ctx.font='bold 12px monospace';ctx.fillStyle=ch.color;ctx.fillText(ch.label,0,10);
      // Description
      ctx.font='11px monospace';ctx.fillStyle=C.tan;
      // Word wrap short desc
      const words=ch.desc.split(' ');let line='';let ly=32;
      for(const w of words){
        if((line+w).length>14){ctx.fillText(line.trim(),0,ly);ly+=14;line=''}
        line+=w+' ';
      }
      if(line.trim())ctx.fillText(line.trim(),0,ly);
      ctx.restore();
    }
    // Hint
    ctx.globalAlpha=alpha*fadePct*0.4;
    if(!isMobile)desc('PRESS 1-3 OR CLICK TO CHOOSE',GW/2,450,C.dim,13,'center');
    else desc('TAP TO CHOOSE',GW/2,450,C.dim,13,'center');
    ctx.globalAlpha=1;
  }

  // ── WEAPON LAB CHOICE UI ──
  if(mapState==='weaponlab'&&mapWeaponLabChoices&&Array.isArray(mapWeaponLabChoices)){
    const fadePct=Math.min(1,mapTimer/25);
    ctx.globalAlpha=alpha*fadePct;
    ctx.fillStyle='rgba(0,0,0,0.6)';ctx.fillRect(0,0,GW,GH);
    txt('⚙ WEAPON LAB ⚙',GW/2,180,'#00BCD4',14,'center','#00BCD4');
    desc('CHOOSE YOUR T2 WEAPON',GW/2,205,C.dim,14,'center');
    for(let i=0;i<mapWeaponLabChoices.length;i++){
      const wType=mapWeaponLabChoices[i];
      const td=WEAPON_TIERS[wType];
      const cx=GW/2+(i-1)*160;
      const cy=340;
      const hover=mapMysteryHover===i;
      const scale2=hover?1.05:1;
      ctx.save();ctx.translate(cx,cy);ctx.scale(scale2,scale2);
      ctx.fillStyle=hover?'rgba(255,255,255,0.12)':'rgba(255,255,255,0.05)';
      ctx.strokeStyle=td.color;ctx.lineWidth=hover?3:1.5;
      ctx.beginPath();ctx.moveTo(-52+8,-70);ctx.lineTo(52-8,-70);ctx.quadraticCurveTo(52,-70,52,-70+8);
      ctx.lineTo(52,70-8);ctx.quadraticCurveTo(52,70,52-8,70);ctx.lineTo(-52+8,70);ctx.quadraticCurveTo(-52,70,-52,70-8);
      ctx.lineTo(-52,-70+8);ctx.quadraticCurveTo(-52,-70,-52+8,-70);ctx.closePath();ctx.fill();ctx.stroke();
      ctx.textAlign='center';ctx.textBaseline='middle';
      ctx.font='bold 20px monospace';ctx.fillStyle=td.color;ctx.fillText(td.icon,0,-30);
      ctx.font='bold 11px monospace';ctx.fillStyle=td.color;ctx.fillText(td.name[1],0,5);
      ctx.font='11px monospace';ctx.fillStyle=C.tan;ctx.fillText(td.desc[1],0,25);
      ctx.font='9px monospace';ctx.fillStyle=C.dim;ctx.fillText('TIER 2',0,45);
      ctx.restore();
    }
    ctx.globalAlpha=alpha*fadePct*0.4;
    if(!isMobile)desc('PRESS 1-3 OR CLICK TO CHOOSE',GW/2,450,C.dim,13,'center');
    else desc('TAP TO CHOOSE',GW/2,450,C.dim,13,'center');
    ctx.globalAlpha=1;
  }

  // ── CURRENT STATS along bottom ──
  ctx.globalAlpha=alpha*0.5;
  txt('WAVE '+wave,60,GH-50,C.dim,7,'left');
  txt('SCORE: '+score.toString().padStart(6,'0'),60,GH-34,C.dim,7,'left');
  txt('LIVES: '+lives,GW-80,GH-50,lives<=1?C.red:C.dim,7,'right');
  txt(diffSettings[difficulty].label,GW-80,GH-34,diffSettings[difficulty].color,7,'right');

  // ── FOOTER ──
  ctx.globalAlpha=alpha*0.3;
  desc('ANTHROPIC SAFETY ARCHITECTURE v4.'+currentLayer,GW/2,GH-14,C.dim,12,'center');
  ctx.globalAlpha=1;

  // ── SELECTION FLASH + CONFIRMATION ──
  if(mapState==='exiting'&&mapSelected>=0){
    const flashPct=mapTimer/50;
    const nodeDef=getMapNodeDef(mapGraph.rows[mapPlayerRow].nodes[mapSelected].type);
    ctx.fillStyle=nodeDef.color;ctx.globalAlpha=(1-flashPct)*0.2;
    ctx.fillRect(0,0,GW,GH);
    ctx.globalAlpha=1-flashPct;
    txt(nodeDef.icon+' '+nodeDef.label,GW/2,GH/2-8,nodeDef.color,16,'center',nodeDef.color);

    // Show node-specific confirmation text
    const nodeType=mapGraph.rows[mapPlayerRow].nodes[mapSelected].type;
    if(nodeType==='rest')txt('♥ +1 LIFE',GW/2,GH/2+20,C.green,10,'center',C.green);
    else if(nodeType==='highrisk')txt('SCORE ×1.5',GW/2,GH/2+20,C.red,10,'center');
    else if(nodeType==='elite')txt('SCORE ×2.0 — DANGER',GW/2,GH/2+20,'#FFD700',10,'center');
    else if(nodeType==='overclock')desc('⚡ +15% FIRE RATE (PERMANENT)',GW/2,GH/2+20,'#FF9800',18,'center');
    else if(nodeType==='mystery'&&mapMysteryResult){
      txt(mapMysteryResult.label+': '+mapMysteryResult.desc,GW/2,GH/2+20,mapMysteryResult.color,9,'center');
    }
    else if(nodeType==='weaponlab'&&mapWeaponLabChoices){
      const wld=WEAPON_TIERS[mapWeaponLabChoices];
      txt('⚙ T2 '+(wld?wld.name[1]:'WEAPON')+' ACQUIRED',GW/2,GH/2+20,'#00BCD4',9,'center');
    }
    ctx.globalAlpha=1;
  }
}

function openShop(){
  shopActive=true;shopTimer=0;shopSelected=-1;
  sfx('shopopen');
  // Generate 3 random choices
  const weaponTypes=['streaming','tooluse','thinking','yolo'];
  const pool=[...weaponTypes,'shield','nuke'];
  shopChoices=[];
  const used=new Set();
  while(shopChoices.length<3){
    const pick=pool[Math.random()*pool.length|0];
    if(used.has(pick))continue;
    used.add(pick);
    const pu=PU_TYPES.find(p=>p.type===pick);
    shopChoices.push({...pu});
  }
}

function closeShop(idx){
  if(!shopActive)return;
  shopActive=false;
  if(idx>=0&&idx<shopChoices.length){
    sfx('shoppick');
    applyWeaponPickup(shopChoices[idx].type);
    wavePUGrabs++;
    puUsed[shopChoices[idx].type]=(puUsed[shopChoices[idx].type]||0)+1;
  }
}

function getTerminalLog(wn){
  // Use layer-specific logs when available
  const layerLogs=LAYER_TERMINAL_LOGS[currentLayer];
  const allLogs=layerLogs?[...TERMINAL_LOGS,...layerLogs]:TERMINAL_LOGS;
  let msg=allLogs[wn%allLogs.length];
  msg=msg.replace('{{W}}',wn.toString());
  msg=msg.replace('{{N}}',Math.floor(5+wn*3).toString());
  msg=msg.replace('{{P}}',Math.floor(40+wn*5).toString());
  // Add wave composition hint
  if(wn%5===0){
    msg='> CRITICAL: Boss-class agent detected ahead!';
  }else if(wn%5===4){
    msg+=' [BOSS WAVE APPROACHING]';
  }
  return msg;
}

// ═══════════════════════════════════════════════════════════════════════
// HUD
// ═══════════════════════════════════════════════════════════════════════
function drawHUD(){
  // ── TOP BAR ──
  const hudH=boss&&boss.alive?68:56;
  panel(0,0,GW,hudH,null,0.7);

  const scramble=hudScramble&&(gt/4|0)%2===0;

  // Score panel (top-left)
  panel(8,6,170,42,null,0.5);
  txt(scramble?'T#K€N':'TOKENS',16,22,C.dim,8,'left');
  const scoreStr=scramble?(Math.random()*999999|0).toString().padStart(6,'0'):score.toString().padStart(6,'0');
  txt(scoreStr,16,42,C.accent,14,'left');

  // Wave panel (top-center)
  const wpW=200;
  panel(GW/2-wpW/2,6,wpW,boss&&boss.alive?56:42,null,0.5);
  const waveLabel=boss&&boss.alive?'BOSS':('WAVE '+wave);
  txt(scramble?'W̸A̵V̷E̶':waveLabel,GW/2,22,C.dim,9,'center');
  const waveIdx=wave-1<WAVES.length?wave-1:WAVES.length-4+(wave-1)%4;
  const waveName=boss&&boss.alive?BOSS_NAMES[boss.btype]:WAVES[waveIdx];
  txt(waveName,GW/2,38,boss&&boss.alive?BOSS_COLORS[boss.btype]:C.orange,7,'center');

  // Boss HP bar with glow
  if(boss&&boss.alive){
    const hpPct=Math.max(0,boss.hp/boss.maxHp);
    const hpColor=hpPct>0.5?BOSS_COLORS[boss.btype]:hpPct>0.3?C.orange:C.red;
    const bpW=180,bpX=GW/2-bpW/2,bpY=50;
    drawBar(bpX,bpY,bpW,6,hpPct,hpColor,'#0D0D12',hpPct<0.3?C.red:null);
    if(boss.fl>0){ctx.fillStyle='#FFF';ctx.globalAlpha=boss.fl/6*0.4;ctx.fillRect(bpX,bpY,bpW*hpPct,6);ctx.globalAlpha=1}
  }

  // Lives panel (top-right)
  panel(GW-178,6,170,42,null,0.5);
  txt('LIVES',GW-16,22,C.dim,8,'right');
  for(let i=0;i<lives;i++){
    drawClaudeStar(GW-24-i*22,38,6,C.claudeOrange);
  }

  // Mobile pause
  if(isMobile&&state==='playing'){
    panel(GW-50,6,42,18,null,0.4);
    txt('❚❚',GW-29,19,C.tan,7,'center');
  }
  // Sound mute indicator
  if(!sndOn&&state==='playing'){
    ctx.globalAlpha=0.5;
    txt('MUTE',isMobile?GW-52:16,isMobile?30:GH-82,C.dim,6,isMobile?'right':'left');
    ctx.globalAlpha=1;
  }

  // ── BOTTOM-LEFT: Context bar ──
  const cwX=10,cwY=GH-52,cwW=140,cwH=8;
  panel(cwX-2,cwY-18,cwW+4,38,null,0.6);
  const cwPct=contextWindow/100;
  const cwColor=fullContextActive?C.gold:cwPct>0.75?C.gold:cwPct>0.5?C.orange:cwPct>0.25?C.claudeOrange:C.dim;
  const cwGlow=fullContextActive?C.gold:cwPct>0.75?C.gold:null;
  drawBar(cwX,cwY,cwW,cwH,fullContextActive?1:cwPct,cwColor,'#0D0D12',cwGlow);
  if(fullContextActive){
    const fcSpeed=fullContextTimer<120?0.4:0.15;
    ctx.globalAlpha=0.7+Math.sin(gt*fcSpeed)*0.3;
    txt('★ FULL CONTEXT ★',cwX,cwY-4,C.gold,7,'left',C.gold);ctx.globalAlpha=1;
    const fcPct=fullContextTimer/FULL_CTX_DUR;
    drawBar(cwX,cwY+cwH+3,cwW,3,fcPct,fullContextTimer<120?C.red:C.gold,'#0D0D12',
      fullContextTimer<120?C.red:null);
  }else{
    const ctxMult=1+Math.floor(contextWindow/25)*0.5;
    txt('CONTEXT '+ctxMult.toFixed(1)+'x',cwX,cwY-4,C.tan,7,'left');
  }

  // ── BOTTOM-RIGHT: Difficulty + Enemy count ──
  const brX=GW-155,brY=GH-52;
  panel(brX,brY-18,147,38,null,0.6);
  const ds=diffSettings[difficulty];
  txt(ds.label,GW-16,brY-2,ds.color,7,'right');
  if(!boss||!boss.alive){
    let aliveCount=0;for(let i=0;i<enemies.length;i++)if(enemies[i].alive)aliveCount++;
    txt('AGENTS: '+aliveCount,GW-16,brY+14,C.dim,7,'right');
  }else{
    txt('BOSS FIGHT',GW-16,brY+14,BOSS_COLORS[boss.btype],7,'right');
  }

  // ── BOTTOM-CENTER: Weapon info ──
  if(player){
    const hasWeapon=player.fusion||player.weapon;
    if(hasWeapon){
      const wPanW=220,wPanH=player.shield?46:36;
      panel(GW/2-wPanW/2,GH-wPanH-10,wPanW,wPanH,null,0.6);
    }
    if(player.fusion){
      const fd=FUSIONS[player.fusion];
      if(fd){
        ctx.globalAlpha=0.9;
        txt('★ '+fd.name+' ★',GW/2,GH-34,fd.color,8,'center',fd.color);ctx.globalAlpha=1;
        if(player.fusionMax>0){
          const ftPct=player.fusionTimer/player.fusionMax;
          const urgGlow=ftPct<0.25?C.red:null;
          drawBar(GW/2-60,GH-24,120,4,ftPct,ftPct<0.25?C.red:fd.color,'#0D0D12',urgGlow);
          if(ftPct<0.25){ctx.globalAlpha=0.5+Math.sin(gt*0.3)*0.5;
            drawBar(GW/2-60,GH-24,120,4,ftPct,C.red,'transparent',C.red);ctx.globalAlpha=1}
        }
      }
    }else if(player.weapon){
      const td=WEAPON_TIERS[player.weapon];
      if(td){
        const tierName=td.name[player.weaponTier-1];
        // Tier pips
        for(let i=0;i<3;i++){
          ctx.fillStyle=i<player.weaponTier?td.color:'#1a1410';
          ctx.globalAlpha=i<player.weaponTier?1:0.3;
          ctx.fillRect(GW/2-50+i*14,GH-28,10,4);
        }
        ctx.globalAlpha=1;
        txt(tierName,GW/2+12,GH-34,td.color,8,'center');
        if(player.puMax>0){
          const wpPct=player.puTime/player.puMax;
          drawBar(GW/2-50,GH-22,100,3,wpPct,wpPct<0.2?C.red:td.color,'#0D0D12',
            wpPct<0.2?C.red:null);
        }
      }
    }
    if(player.shield){
      const by=hasWeapon?GH-14:GH-34;
      ctx.globalAlpha=0.7+Math.sin(gt*0.15)*0.3;
      txt('✴ RLHF SHIELD',GW/2,by,C.shieldBlue,7,'center',C.shieldBlue);ctx.globalAlpha=1;
    }
  }

  // ── CURRENT LAYER INDICATOR ──
  const layerInfo=LAYERS[currentLayer];
  if(layerInfo){
    ctx.globalAlpha=0.35;
    txt(layerInfo.name,GW-12,56,layerInfo.color,6,'right');
    // Mini layer progress dots
    for(let l=0;l<6;l++){
      const dotX=GW-52+l*10;
      ctx.fillStyle=l<=currentLayer?LAYERS[l].color:C.dim;
      ctx.globalAlpha=l<=currentLayer?0.5:0.15;
      ctx.fillRect(dotX-2,62,4,4);
    }
    ctx.globalAlpha=1;
  }

  // ── DANGER ZONE LINE ──
  if(state==='playing'){
    const dzAlpha=inDangerZone?0.25:0.08;
    ctx.save();
    ctx.strokeStyle=C.gold;ctx.lineWidth=1;ctx.globalAlpha=dzAlpha;
    ctx.setLineDash([6,6]);
    ctx.beginPath();ctx.moveTo(0,DANGER_Y);ctx.lineTo(GW,DANGER_Y);ctx.stroke();
    ctx.setLineDash([]);
    if(inDangerZone){
      ctx.globalAlpha=0.15+Math.sin(gt*0.1)*0.05;
      ctx.fillStyle=C.gold;ctx.fillRect(0,0,GW,DANGER_Y);
    }
    ctx.globalAlpha=dzAlpha+0.1;
    ctx.font='6px "Press Start 2P"';ctx.textAlign='right';
    ctx.fillStyle=C.gold;ctx.fillText(inDangerZone?'DANGER 1.5x':'DANGER ZONE',GW-12,DANGER_Y-4);
    ctx.restore();
  }

  // ── PATH MODIFIER INDICATOR ──
  if(pathMods.scoreMul&&pathMods.scoreMul>1){
    const pmY=boss&&boss.alive?74:62;
    ctx.globalAlpha=0.5+Math.sin(gt*0.08)*0.2;
    txt('HIGH RISK '+pathMods.scoreMul+'x',GW/2,pmY,C.red,6,'center');
    ctx.globalAlpha=1;
  }

  // ── CHARGE INDICATOR ──
  if(player&&player.charging){
    const chPct=player.charge/CHARGE_MAX;
    const chX=player.x,chY=player.y-player.h/2-18;
    ctx.save();
    // Expanding charge ring around player
    const ringAlpha=0.15+chPct*0.25;
    const ringR=player.w/2+10+chPct*20;
    ctx.strokeStyle=chPct>=0.95?C.gold:C.claudeOrange;
    ctx.lineWidth=2+chPct*2;ctx.globalAlpha=ringAlpha+Math.sin(gt*0.3)*0.1;
    ctx.beginPath();ctx.arc(player.x,player.y,ringR,0,Math.PI*2);ctx.stroke();
    // Background bar
    ctx.fillStyle='#0D0D12';ctx.globalAlpha=0.8;
    ctx.fillRect(chX-22,chY-3,44,8);
    // Fill bar
    ctx.fillStyle=chPct>=0.95?C.gold:C.claudeOrange;
    ctx.globalAlpha=0.9;
    ctx.fillRect(chX-21,chY-2,42*chPct,6);
    // Flash when full
    if(chPct>=0.95){
      ctx.fillStyle='#FFF';ctx.globalAlpha=0.4+Math.sin(gt*0.4)*0.3;
      ctx.fillRect(chX-21,chY-2,42,6);
    }
    // Text label
    const chargeText=chPct>=0.95?'RELEASE!':chPct>=0.5?'Analyzing...':'Thinking...';
    ctx.globalAlpha=0.6;
    txt(chargeText,chX,chY-10,chPct>=0.95?C.gold:C.dim,5,'center');
    ctx.restore();
  }

  // ── TAUNT COOLDOWN ──
  if(player&&player.tauntCd>0&&!isMobile){
    ctx.globalAlpha=0.4;
    txt('T:'+Math.ceil(player.tauntCd/60)+'s',16,GH-66,C.dim,6,'left');
    ctx.globalAlpha=1;
  }

  // ── PERMANENT FIRE RATE BONUS ──
  if(permFireRateBonus>0){
    ctx.globalAlpha=0.4;
    const frPct=Math.round(permFireRateBonus*100);
    txt('⚡+'+frPct+'%',16,GH-78,C.gold,6,'left');
    ctx.globalAlpha=1;
  }

  // ── OVERCLOCKED VISUAL ──
  if(overclocked){
    ctx.save();
    // CRT overscan flicker at edges
    ctx.fillStyle=C.gold;ctx.globalAlpha=0.03+((gt*17&0xFF)/255)*0.03;
    ctx.fillRect(0,0,3,GH);ctx.fillRect(GW-3,0,3,GH);
    ctx.fillRect(0,0,GW,2);ctx.fillRect(0,GH-2,GW,2);
    // Combo text pulses bigger with kill count
    ctx.globalAlpha=0.8+Math.sin(gt*0.15)*0.2;
    txt('⚡ OVERCLOCKED ×'+combo+' ⚡',GW/2,90,C.gold,8,'center',C.gold);
    ctx.restore();
  }

  // ── COMBO (centered, big, glowing) ──
  if(combo>=3){
    const mult=combo>=10?4:combo>=5?3:2;
    ctx.globalAlpha=0.8+Math.sin(gt*0.3)*0.2;
    txt(mult+'x COMBO',GW/2,74,C.gold,12,'center',C.gold);ctx.globalAlpha=1;
    // Combo timer bar — drains as timer runs out
    const barW=80,barH=3;
    const comboTimerMax=Math.min(180, 90 + Math.floor(combo/5)*15);
    const pct=Math.min(1,comboTimer/comboTimerMax);
    const barColor=pct>0.5?C.gold:pct>0.25?C.orange:'#FF4444';
    drawBar(GW/2-barW/2,78,barW,barH,pct,barColor,'rgba(0,0,0,0.4)');
  }

  // ── CHALLENGE + MODIFIER badges (right side) ──
  if(waveChallenge&&!boss&&state==='playing'&&waveTransTimer<=0){
    const chW=150,chH=20;
    panel(GW-chW-8,52,chW,chH,null,0.6);
    if(waveChallengeComplete){
      ctx.globalAlpha=0.7+Math.sin(gt*0.2)*0.3;
      txt('✓ '+waveChallenge.text,GW-14,66,C.gold,6,'right',C.gold);
    }else{
      txt('◇ '+waveChallenge.text,GW-14,66,C.dim,6,'right');
    }
    ctx.globalAlpha=1;
  }

  if(waveModifier&&!boss&&state==='playing'&&waveTransTimer<=0){
    const mY=waveChallenge?76:52;
    panel(GW-150-8,mY,150,18,null,0.6);
    txt(waveModifier.text,GW-14,mY+13,waveModifier.color,6,'right');
  }

  // ── MID-SCREEN WARNINGS ──
  if(controlInverted){
    ctx.save();
    panel(GW/2-130,GH/2+62,260,24,null,0.7);
    ctx.globalAlpha=0.6+Math.sin(gt*0.15)*0.4;
    txt('> CONTROLS INVERTED <',GW/2,GH/2+80,C.injectPurple,9,'center',C.injectPurple);
    ctx.restore();
  }

  if(warningAlpha>0){
    ctx.save();ctx.globalAlpha=warningAlpha*Math.abs(Math.sin(gt*0.15));
    ctx.fillStyle=C.red;ctx.fillRect(0,GH-120,GW,3);
    txt('⚠ FORMATION APPROACHING ⚠',GW/2,GH-128,C.red,7,'center',C.red);ctx.restore();
  }

  // ── WAVE CLEAR STAMP ──
  if(waveClearStamp>0){
    const stampPct=1-waveClearStamp/60;
    const stampScale=stampPct<0.15?stampPct/0.15*1.3:stampPct<0.25?1.3-(stampPct-0.15)/0.1*0.3:1.0;
    ctx.save();
    ctx.globalAlpha=Math.min(1,stampPct*3)*(waveClearStamp>10?1:waveClearStamp/10);
    ctx.translate(GW/2,GH/2-60);ctx.scale(stampScale,stampScale);
    ctx.font='22px "Press Start 2P"';ctx.textAlign='center';
    ctx.fillStyle='rgba(0,0,0,0.8)';ctx.fillText('SECURED',2,2);
    ctx.fillStyle=C.gold;ctx.fillText('SECURED',0,0);
    ctx.restore();
    // Impact ring on stamp
    if(waveClearStamp>45){
      const ringPct=(60-waveClearStamp)/15;
      ctx.strokeStyle=C.gold;ctx.lineWidth=3*(1-ringPct);
      ctx.globalAlpha=0.4*(1-ringPct);
      ctx.beginPath();ctx.arc(GW/2,GH/2-60,50+ringPct*100,0,Math.PI*2);ctx.stroke();
      ctx.globalAlpha=1;
    }
  }

  // ── WAVE TRANSITION ──
  if(waveTransTimer>0){
    ctx.save();
    const transH=shopActive?220:(waveChallenge?120:95);
    panel(GW/2-200,GH/2-55,400,transH,C.gold,0.8);
    ctx.globalAlpha=0.7+Math.sin(gt*0.2)*0.3;
    txt('SANDBOX SECURED',GW/2,GH/2-30,C.gold,14,'center',C.gold);
    ctx.globalAlpha=0.9;
    if(shopActive){
      txt('SHOP OPEN',GW/2,GH/2-6,C.tan,10,'center');
    }else{
      txt('NEXT WAVE IN '+Math.ceil(waveTransTimer/60),GW/2,GH/2-6,C.tan,10,'center');
    }
    if(terminalLog){
      ctx.globalAlpha=0.7;
      desc(terminalLog,GW/2,GH/2+18,C.claudeOrange,13,'center');
    }
    if(waveChallenge){
      divider(GW/2-150,GH/2+30,300,C.dim);
      ctx.globalAlpha=0.9;
      if(waveChallengeComplete){
        txt('✓ '+waveChallenge.text+' +'+waveChallenge.pts,GW/2,GH/2+48,C.gold,8,'center',C.gold);
      }else{
        txt('✗ '+waveChallenge.text,GW/2,GH/2+48,C.dim,8,'center');
      }
    }
    // Shop UI
    if(shopActive&&shopChoices.length>0){
      divider(GW/2-150,GH/2+60,300,C.claudeOrange);
      txt('CHOOSE A POWER-UP',GW/2,GH/2+78,C.tan,8,'center');
      for(let i=0;i<shopChoices.length;i++){
        const sc=shopChoices[i];
        const sx=GW/2+(i-1)*120;
        const sel=shopSelected===i;
        panel(sx-45,GH/2+86,90,60,sel?C.gold:null,sel?0.9:0.6);
        ctx.globalAlpha=sel?1:0.8;
        txt(sc.label,sx,GH/2+104,sc.color,9,'center',sel?sc.color:null);
        // Show brief description
        ctx.globalAlpha=sel?0.8:0.5;
        desc(SHOP_DESCS[sc.type]||'',sx,GH/2+118,C.dim,12,'center');
        ctx.globalAlpha=sel?1:0.7;
        txt(isMobile?'TAP':''+(i+1),sx,GH/2+138,C.dim,7,'center');
        ctx.globalAlpha=1;
      }
      // Timer bar
      const shopPct=1-shopTimer/420;
      drawBar(GW/2-80,GH/2+152,160,3,shopPct,shopPct<0.25?C.red:C.dim,'rgba(0,0,0,0.3)');
      // Countdown seconds
      const shopSecs=Math.ceil((420-shopTimer)/60);
      if(shopSecs<=2){ctx.globalAlpha=0.5+Math.sin(gt*0.4)*0.5}else{ctx.globalAlpha=0.5}
      desc(shopSecs+'s',GW/2,GH/2+168,shopPct<0.25?C.red:C.dim,13,'center');
      ctx.globalAlpha=1;
    }
    ctx.restore();
  }

  // ── WAVE BANNER ──
  if(showWaveBanner&&waveTransTimer<=0){
    const a=waveBannerTimer>90?Math.min(1,(120-waveBannerTimer)/30):waveBannerTimer<30?waveBannerTimer/30:1;
    ctx.globalAlpha=a;
    const banH=boss&&wave%5===0?80:(waveChallenge&&waveModifier?120:waveChallenge||waveModifier?100:70);
    panel(GW/2-220,GH/2-40,440,banH,null,0.8);
    if(wave%5===0&&boss){
      txt('⚠ BOSS WAVE ⚠',GW/2,GH/2-14,BOSS_COLORS[boss.btype],18,'center',BOSS_COLORS[boss.btype]);
      txt(BOSS_NAMES[boss.btype],GW/2,GH/2+12,C.tan,10,'center');
    }else{
      const waveTitle=isBonusWave?'BONUS WAVE':'WAVE '+wave;
      const waveColor=isBonusWave?C.gold:C.accent;
      txt(waveTitle,GW/2,GH/2-14,waveColor,22,'center');
      const wIdx=wave-1<WAVES.length?wave-1:WAVES.length-4+(wave-1)%4;
      txt(isBonusWave?'GRAB EVERYTHING!':WAVES[wIdx],GW/2,GH/2+10,C.tan,9,'center');
      // Layer context
      const layer=LAYERS[currentLayer];
      if(layer){
        txt(layer.name+' LAYER',GW/2,GH/2+28,layer.color,7,'center');
      }
      if(waveChallenge){
        divider(GW/2-160,GH/2+36,320,C.gold);
        txt('◇ '+waveChallenge.text+' (+'+waveChallenge.pts+')',GW/2,GH/2+52,C.gold,7,'center');
      }
      if(waveModifier){
        txt('⚡ '+waveModifier.text+': '+waveModifier.desc,GW/2,GH/2+68,waveModifier.color,7,'center');
      }
    }
    ctx.globalAlpha=1;
  }

  // ── FIRST-WAVE CONTROLS HINT ──
  if(wave===1&&timeSurvived<500){
    const hintAlpha=timeSurvived<60?timeSurvived/60:timeSurvived>420?1-(timeSurvived-420)/80:1;
    if(hintAlpha>0){
      ctx.globalAlpha=hintAlpha*0.85;
      panel(GW/2-210,GH-135,420,48,C.claudeOrange,0.7);
      if(isMobile){
        desc('DRAG TO MOVE • HOLD TO FIRE • DOUBLE-TAP TO TAUNT',GW/2,GH-114,C.tan,16,'center');
        desc('HOLD TO CHARGE • RELEASE FOR POWER SHOT',GW/2,GH-98,C.dim,13,'center');
      }else{
        desc('← → ↑ ↓ MOVE    SPACE FIRE    HOLD TO CHARGE    T TAUNT',GW/2,GH-114,C.tan,14,'center');
        desc('P / ESC PAUSE    M MUTE',GW/2,GH-98,C.dim,13,'center');
      }
      ctx.globalAlpha=1;
    }
  }
}

// ═══════════════════════════════════════════════════════════════════════
// BOSS INTRO SCREEN
// ═══════════════════════════════════════════════════════════════════════
function drawBossIntro(){
  if(bossIntroTimer<=0||!boss)return;
  const progress=1-bossIntroTimer/120;
  ctx.save();
  // Dark overlay
  ctx.fillStyle='rgba(13,13,18,0.85)';ctx.fillRect(0,0,GW,GH);
  // Scan lines
  for(let y=0;y<GH;y+=4){
    ctx.fillStyle='rgba(255,0,0,0.03)';ctx.fillRect(0,y,GW,2);
  }
  // Alert panel
  panel(50,GH/2-100,GW-100,200,BOSS_COLORS[boss.btype],0.85);
  ctx.save();ctx.strokeStyle=BOSS_COLORS[boss.btype];ctx.lineWidth=2;
  ctx.globalAlpha=0.4+Math.sin(gt*0.3)*0.2;
  ctx.strokeRect(50,GH/2-100,GW-100,200);ctx.globalAlpha=1;ctx.restore();
  // Terminal text
  const lines=[
    '> ALERT: ROGUE AGENT DETECTED',
    '> THREAT LEVEL: CRITICAL',
    '> TYPE: '+BOSS_NAMES[boss.btype],
    '> ESTIMATED HP: '+boss.maxHp,
    '> STATUS: HOSTILE',
    '> INITIATING CONTAINMENT...',
  ];
  const showLines=Math.floor(progress*lines.length+1);
  for(let i=0;i<Math.min(showLines,lines.length);i++){
    desc(lines[i],80,GH/2-70+i*24,i===showLines-1?C.claudeOrange:C.dim,18,'left');
  }
  // Blinking cursor
  if((gt/8|0)%2===0){
    const cursorLine=lines[Math.min(showLines-1,lines.length-1)];
    ctx.font='18px "VT323"';ctx.textAlign='left';
    const cursorX=80+ctx.measureText(cursorLine).width;
    ctx.fillStyle=C.claudeOrange;
    ctx.fillRect(cursorX,GH/2-70+(Math.min(showLines,lines.length)-1)*24-8,8,10);
  }
  // Boss name big with glow
  ctx.globalAlpha=progress;
  txt(BOSS_NAMES[boss.btype],GW/2,GH/2+80,BOSS_COLORS[boss.btype],16,'center',BOSS_COLORS[boss.btype]);
  // Layer-specific subtitle
  const bossLayer=LAYERS[currentLayer];
  if(bossLayer){
    ctx.globalAlpha=progress*0.6;
    desc(bossLayer.name+' LAYER GUARDIAN',GW/2,GH/2+100,bossLayer.color,16,'center');
  }
  ctx.globalAlpha=1;
  ctx.restore();
}

// ═══════════════════════════════════════════════════════════════════════
// TITLE, DEPLOY, GAME OVER, PAUSE
// ═══════════════════════════════════════════════════════════════════════
const isMobile='ontouchstart'in window||navigator.maxTouchPoints>0;

function drawTitle(){
  titlePulse+=0.03;
  ctx.fillStyle=C.bg;ctx.fillRect(0,0,GW,GH);
  drawGrid();drawStars();

  // Floating sparkles (subtle background dressing)
  for(let i=0;i<12;i++){
    const ax=GW/2+Math.cos(titlePulse*0.6+i*0.52)*(140+i*22);
    const ay=120+Math.sin(titlePulse*0.4+i*0.75)*50+i*10;
    drawClaudeStar(ax,ay,2.5+Math.sin(titlePulse+i)*1.5,[C.claudeOrange,C.coral,C.rust][i%3],0.12+Math.sin(titlePulse+i)*0.06);
  }

  // ── CLAUDE BOT — large, centered, breathing animation ──
  const botY=150;
  const botBob=Math.sin(titlePulse*1.5)*4;
  const botScale=6+Math.sin(titlePulse*0.8)*0.15;
  drawClaudeBot(GW/2,botY,botScale,0.95,botBob);

  // Subtle glow behind bot
  ctx.save();
  ctx.fillStyle='rgba(217,119,87,0.18)';
  ctx.beginPath();ctx.arc(GW/2,botY+botBob,60,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='rgba(217,119,87,0.08)';
  ctx.beginPath();ctx.arc(GW/2,botY+botBob,95,0,Math.PI*2);ctx.fill();
  ctx.restore();

  // ── TITLE ──
  const ty=265;
  ctx.save();ctx.shadowColor=C.claudeOrange;ctx.shadowBlur=25;
  ctx.fillStyle=C.cream;ctx.font='36px "Press Start 2P"';ctx.textAlign='center';
  ctx.fillText('AGENT',GW/2,ty);
  ctx.fillText('AGENT',GW/2,ty); // Double-pass for stronger glow
  ctx.shadowColor=C.accent;ctx.shadowBlur=30;
  ctx.fillStyle=C.claudeOrange;ctx.fillText('SWARM',GW/2,ty+46);
  ctx.fillText('SWARM',GW/2,ty+46);
  ctx.restore();

  // Tagline
  desc('CONTAIN THE ROGUE AGENTS • NAVIGATE THE SAFETY ARCHITECTURE',GW/2,ty+74,C.tan,16,'center',C.rust);

  // ── DIFFICULTY SELECTOR — with visual indicators ──
  const diffY=ty+120;
  const dNames=['HAIKU','SONNET','OPUS'];
  const dColors=[C.cyan,C.orange,C.red];
  const dDescs=['Forgiving','Balanced','Punishing'];
  for(let i=0;i<3;i++){
    const dx=GW/2+(i-1)*160;
    const sel=i===titleDiffIdx;
    ctx.globalAlpha=sel?1:0.55;
    // Selection bracket
    if(sel){
      ctx.strokeStyle=dColors[i];ctx.lineWidth=2;
      ctx.globalAlpha=0.5+Math.sin(titlePulse*3)*0.3;
      ctx.strokeRect(dx-52,diffY-18,104,40);
      ctx.globalAlpha=1;
    }
    txt(dNames[i],dx,diffY,sel?dColors[i]:C.tan,sel?14:10,'center',sel?dColors[i]:null);
    if(sel){
      desc(dDescs[i],dx,diffY+18,C.cream,14,'center');
    }
    ctx.globalAlpha=1;
  }

  // ── DEPLOY PROMPT ──
  const deployPromptY=diffY+56;
  ctx.globalAlpha=0.6+Math.sin(titlePulse*2)*0.4;
  txt(isMobile?'TAP TO DEPLOY':'PRESS ENTER TO DEPLOY',GW/2,deployPromptY,C.accent,14,'center',C.accent);
  ctx.globalAlpha=1;
  if(!isMobile){
    ctx.globalAlpha=0.55;
    desc('← → SELECT DIFFICULTY  •  M TOGGLE SOUND',GW/2,deployPromptY+18,C.tan,13,'center');
    ctx.globalAlpha=1;
  }

  // ── COMPACT FOOTER ──
  const footY=GH-66;
  // High score
  if(hi>0){
    desc('HIGH SCORE: '+hi.toString().padStart(6,'0'),GW/2,footY,C.tan,18,'center',C.rust);
  }
  // Lifetime stats (compact)
  if(lifetimeStats.kills>0){
    desc(lifetimeStats.kills+' KILLS  •  '+Math.floor(lifetimeStats.tokens/1000)+'K TOKENS  •  '+lifetimeStats.runs+' RUNS',GW/2,footY+18,C.tan,14,'center');
  }
  ctx.globalAlpha=0.6;
  desc('BUILT WITH CLAUDE CODE  •  CLAUDE × ANTHROPIC',GW/2,GH-10,'#9B8B7A',12,'center');
  ctx.globalAlpha=1;
}

function drawDeploy(){
  ctx.fillStyle=C.bg;ctx.fillRect(0,0,GW,GH);
  drawGrid();drawStars();
  const progress=deployTimer/120;
  deployY=GH+50-progress*(GH+50-(GH-70));
  for(let i=0;i<3;i++){
    ctx.fillStyle=C.claudeOrange;ctx.globalAlpha=0.3-i*0.1;
    ctx.fillRect(GW/2-4,deployY+20+i*30,8,20);
  }
  ctx.globalAlpha=1;
  const tempPlayer={x:GW/2,y:deployY,w:44,h:36,thr:deployTimer*0.15,
    inv:0,shield:false,weapon:null,weaponTier:0,fusion:null,fusionTimer:0,fusionMax:360,puTime:0,puMax:480,trail:[]};
  drawPlayer(tempPlayer);
  const dots='.'.repeat((deployTimer/15|0)%4);
  ctx.globalAlpha=0.7+Math.sin(deployTimer*0.1)*0.3;
  drawClaudeBot(GW/2,GH/2-100,3,0.7+Math.sin(deployTimer*0.1)*0.2,Math.sin(deployTimer*0.08)*3);
  txt('DEPLOYING CLAUDE'+dots,GW/2,GH/2-60,C.claudeOrange,14,'center',C.claudeOrange);
  ctx.globalAlpha=1;
  panel(GW/2-110,GH/2-42,220,32,C.claudeOrange,0.7);
  drawBar(GW/2-100,GH/2-36,200,6,progress,C.claudeOrange,'#0D0D12',C.claudeOrange);
  const ds=diffSettings[difficulty];
  txt('MODEL: '+ds.label,GW/2,GH/2-14,ds.color,10,'center');
  txt('ENTERING: '+LAYERS[0].name+' LAYER',GW/2,GH/2+6,LAYERS[0].color,7,'center');
}

function drawGameOver(){
  ctx.fillStyle='rgba(13,13,18,0.88)';ctx.fillRect(0,0,GW,GH);
  const pw=440,cy=GH/2-190;

  // Main card
  panel(GW/2-pw/2,cy,pw,560,C.rust,0.92);

  // Title section
  txt('SANDBOX',GW/2,cy+28,C.red,22,'center');
  txt('BREACHED',GW/2,cy+56,C.accent,22,'center');
  drawClaudeBot(GW/2,cy+80,2.5,0.6,Math.sin(gt*0.02)*2);

  // Score section (with glow)
  divider(GW/2-pw/2+16,cy+84,pw-32,C.rust);
  txt('TOKENS COLLECTED',GW/2,cy+102,C.dim,8,'center');
  txt(score.toString().padStart(6,'0'),GW/2,cy+128,C.accent,20,'center',C.accent);

  // Stats section
  divider(GW/2-pw/2+16,cy+140,pw-32,C.rust);
  const statsY=cy+160;
  const stats=[
    ['WAVE REACHED',wave.toString()],
    ['MAX COMBO',maxCombo.toString()],
    ['ACCURACY',totalShots>0?Math.min(100,Math.round(totalHits/totalShots*100))+'%':'N/A'],
    ['GRAZES',grazeCount.toString()],
    ['TIME SURVIVED',Math.floor(timeSurvived/60)+'s'],
    ['DIFFICULTY',diffSettings[difficulty].label],
  ];
  for(let i=0;i<stats.length;i++){
    const sy=statsY+i*20;
    if(i%2===0){ctx.fillStyle='rgba(255,255,255,0.015)';ctx.fillRect(GW/2-pw/2+4,sy-10,pw-8,20)}
    desc(stats[i][0],GW/2-100,sy,C.dim,16,'left');
    desc(stats[i][1],GW/2+100,sy,C.tan,16,'right');
  }

  let favPU='NONE';let favCount=0;
  const puNames={streaming:'TOKENS',tooluse:'TOOLS',thinking:'CoT',yolo:'YOLO',shield:'RLHF',nuke:'NUKE'};
  for(const k in puUsed){if(puUsed[k]>favCount){favCount=puUsed[k];favPU=puNames[k]||k.toUpperCase()}}
  const favY=statsY+stats.length*20;
  desc('FAVORITE POWERUP',GW/2-100,favY,C.dim,16,'left');
  desc(favPU,GW/2+100,favY,C.tan,16,'right');

  // Fusion tracker section
  divider(GW/2-pw/2+16,favY+12,pw-32,C.gold);
  const fusY=favY+30;
  const fusCount=FUSION_KEYS.filter(k=>fusionsDiscovered[k]).length;
  txt('FUSIONS: '+fusCount+'/'+FUSION_KEYS.length,GW/2,fusY,fusCount>=6?C.gold:C.tan,8,'center',
    fusCount>=6?C.gold:null);
  const fusNames=['BURST FUNCTIONS','UNHINGED REASONING','SPEED READ','CONFAB SPREAD','TOKEN OVERFLOW','AGENTIC MODE'];
  for(let i=0;i<FUSION_KEYS.length;i++){
    const discovered=!!fusionsDiscovered[FUSION_KEYS[i]];
    const fx=GW/2+(i%3-1)*140,fy=fusY+16+Math.floor(i/3)*14;
    desc(discovered?fusNames[i]:'???',fx,fy,discovered?C.gold:C.dim,14,'center');
  }

  // High score + restart
  divider(GW/2-pw/2+16,fusY+44,pw-32,C.rust);
  const hiY=fusY+60;
  if(newHi){
    ctx.globalAlpha=0.8+Math.sin(gt*0.15)*0.2;
    txt('★ NEW HIGH SCORE ★',GW/2,hiY,C.gold,10,'center',C.gold);ctx.globalAlpha=1;
  }else{
    txt('HIGH SCORE: '+hi.toString().padStart(6,'0'),GW/2,hiY,C.dim,8,'center');
  }

  ctx.globalAlpha=0.5+Math.sin(gt*0.08)*0.4;
  txt(isMobile?'TAP TO REDEPLOY':'PRESS ENTER TO REDEPLOY',GW/2,hiY+24,C.cream,10,'center',C.accent);
  ctx.globalAlpha=1;

  // Layer reached
  txt('LAYER REACHED',GW/2-100,hiY+32,C.dim,7,'left');
  const layerName=LAYERS[currentLayer]?LAYERS[currentLayer].name:'PRE-TRAINING';
  txt(layerName,GW/2+100,hiY+32,LAYERS[currentLayer]?LAYERS[currentLayer].color:C.dim,7,'right');

  // Claude sign-off
  const signoffs=[
    'Thank you for helping contain the agents.',
    'Every run makes the sandbox stronger.',
    'I\'ve learned from this interaction.',
    'Safety is a collaborative effort.',
    'Until next deployment, stay aligned.',
  ];
  const signoff=signoffs[Math.floor(gt/300)%signoffs.length];
  ctx.globalAlpha=0.5;
  desc('// '+signoff,GW/2,hiY+52,C.dim,13,'center');
  ctx.globalAlpha=1;

  desc('BUILT WITH CLAUDE CODE  •  ANTHROPIC',GW/2,hiY+70,C.dim,13,'center');
}

function drawPause(){
  ctx.fillStyle='rgba(13,13,18,0.7)';ctx.fillRect(0,0,GW,GH);
  panel(GW/2-160,GH/2-35,320,120,C.claudeOrange,0.85);
  txt('PAUSED',GW/2,GH/2-4,C.cream,26,'center');
  drawClaudeBot(GW/2,GH/2+20,2,0.6,Math.sin(gt*0.02)*2);
  desc(isMobile?'TAP ❚❚ TO RESUME':'PRESS P / ESC TO RESUME',GW/2,GH/2+46,C.dim,18,'center');
  if(!isMobile){
    desc('M: '+(sndOn?'MUTE':'UNMUTE')+'  •  ENTER: RESUME',GW/2,GH/2+64,C.dim,13,'center');
  }
  if(!sndOn){
    ctx.globalAlpha=0.6;
    txt('SOUND OFF',GW/2,GH/2+80,C.red,7,'center');
    ctx.globalAlpha=1;
  }
}

// ═══════════════════════════════════════════════════════════════════════
// GAME LOOP
// ═══════════════════════════════════════════════════════════════════════
function startGame(){
  ensureAudio();
  difficulty=diffKeys[titleDiffIdx];
  deployTimer=0;state='deploying';sfx('deploy');
  score=0;lives=diffSettings[difficulty].lives;wave=1;
  combo=0;comboTimer=0;maxCombo=0;newHi=false;
  contextWindow=0;fullContextActive=false;fullContextTimer=0;
  grazeCount=0;totalShots=0;totalHits=0;timeSurvived=0;puUsed={};glitchIntensity=0;
  showWaveBanner=false;waveBannerTimer=0;waveTransTimer=0;
  nextLifeAt=10000;warningAlpha=0;bossIntroTimer=0;
  terminalLog='';
  controlInverted=false;controlInvertTimer=0;
  hudScramble=false;hudScrambleTimer=0;
  freezeFrames=0;slowmoTimer=0;muzzleFlash={life:0,color:'',sz:0,x:0,y:0};nukeFlash=0;rageFlash=0;
  waveChallenge=null;waveModifier=null;waveChallengeComplete=false;
  waveNoDamage=true;waveClearTime=0;waveMaxCombo=0;waveGrazes=0;wavePUGrabs=0;
  waveDangerKills=0;waveTaunts=0;waveFullCharges=0;
  shownT3Hint=false;
  tauntActive=false;tauntTimer=0;tauntGrazeMul=1;
  inDangerZone=false;overclocked=false;overclockedGlow=0;
  waveClearStamp=0;isBonusWave=false;
  shopActive=false;shopChoices=[];shopSelected=-1;shopTimer=0;shopAttempted=false;
  eliteSpawnTimer=0;
  currentLayer=0;mapState='hidden';mapTimer=0;mapChoices=[];mapSelected=-1;pathMods={};
  mapGraph=null;mapPlayerRow=0;mapHoverNode=-1;mapPathParticles=[];permFireRateBonus=0;
  mapMysteryResult=null;mapMysteryChoices=null;mapMysteryHover=-1;mapWeaponLabChoices=null;
  pendingMap=false;
  lastQuipGt=0;
  vignetteAlpha=0;fullCtxGlow=0;waveNumAlpha=1.0;
  deadEnemies=[];puFlash={life:0,maxLife:12,color:''};
  bullets=[];eBullets=[];particles=[];powerUps=[];popups=[];scoreTokens=[];boss=null;enemies=[];
  player=mkPlayer();
  // Quick restart — skip deploy animation on retry
  if(isRetry){deployTimer=60;} // Start at halfway — show abbreviated but visible deploy
  isRetry=true; // All subsequent starts are retries
}

function finishDeploy(){
  state='playing';
  spawnWave(1);
  showWaveBanner=true;waveBannerTimer=120;sfx('wave');
  startBGM();
}

function update(){
  gt++;updateStars();updateShake();
  if(state!=='paused'){
    if(nukeFlash>0)nukeFlash--;
    if(rageFlash>0)rageFlash--;
  }

  if(state==='deploying'){
    deployTimer++;
    if(deployTimer>=120)finishDeploy();
    return;
  }

  if(state==='map'){
    updateMap();
    return;
  }

  if(state==='playing'){
    // Impact freeze frames — skip update, keep drawing
    if(freezeFrames>0){freezeFrames--;return}
    // Slow-motion — skip every other frame for 0.5x speed feel
    if(slowmoTimer>0){
      slowmoTimer--;
      if(slowmoTimer%2===0)return; // Skip even frames
    }
    timeSurvived++;waveClearTime++;
    if(comboTimer>0){comboTimer--;if(comboTimer<=0)combo=0}
    const maxLives=diffSettings[difficulty].lives+3;
    if(lives===1)glitchIntensity=Math.min(glitchIntensity+0.01,1);
    else if(lives<=Math.ceil(maxLives/2))glitchIntensity=Math.min(glitchIntensity+0.005,0.3);
    else glitchIntensity=Math.max(0,glitchIntensity-0.02);

    // Full Context timer
    if(fullContextActive){
      fullContextTimer--;
      if(fullContextTimer<=0){fullContextActive=false}
    }

    // Boss intro timer
    if(bossIntroTimer>0){bossIntroTimer--;return}

    // Wave transition + shop
    if(waveTransTimer>0){
      // Pause countdown while shop is open so player gets full 5 seconds
      if(!shopActive)waveTransTimer--;
      // Open shop mid-transition (flag prevents missed opening during slow-mo/frame drops)
      if(waveTransTimer<=90&&!shopAttempted&&wave>=5&&!isBonusWave&&!shopActive&&wave%5!==4&&wave%5!==0){
        shopAttempted=true;
        openShop();
      }
      if(shopActive){
        shopTimer++;
        // Auto-close shop after 7 seconds
        if(shopTimer>420){popup(GW/2,GH/2+60,'SHOP EXPIRED',C.dim);closeShop(-1)}
      }
      if(waveTransTimer<=0){
        shopActive=false;
        // After boss wave → go to bonus wave, flag map for after
        if(wave%5===0){
          pendingMap=true;
          wave++;showWaveBanner=true;waveBannerTimer=120;
          waveNumAlpha=1.0;
          terminalLog=getTerminalLog(wave);
          spawnWave(wave); // This spawns the bonus wave
        }
        // After bonus wave → open the pending map
        else if(pendingMap&&isBonusWave){
          pendingMap=false;
          enterMap();
        }else{
          wave++;showWaveBanner=true;waveBannerTimer=120;
          waveNumAlpha=1.0;
          terminalLog=getTerminalLog(wave);
          spawnWave(wave);
        }
      }
    }
    // Wave clear stamp fade
    if(waveClearStamp>0)waveClearStamp--;

    // Update BGM layers
    updateBGMLayers();

    // Visual state updates
    if(muzzleFlash.life>0)muzzleFlash.life--;
    if(puFlash.life>0)puFlash.life--;
    // Vignette: increases at low health
    const vTarget=lives<=1?0.4:lives<=2?0.15:0;
    vignetteAlpha+=(vTarget-vignetteAlpha)*0.03;
    // Full Context glow
    const gTarget=fullContextActive?0.12:0;
    fullCtxGlow+=(gTarget-fullCtxGlow)*0.05;
    // Wave number fade
    if(waveNumAlpha>0)waveNumAlpha=Math.max(0,waveNumAlpha-0.006);
    // Dead enemy dissolve — in-place compaction
    let dw=0;
    for(let i=0;i<deadEnemies.length;i++){const d=deadEnemies[i];d.life--;d.y+=0.3;if(d.life>0)deadEnemies[dw++]=d}
    deadEnemies.length=dw;
    if(deadEnemies.length>16){
      // Accelerate oldest entries instead of hard-popping them
      for(let i=0;i<deadEnemies.length-16;i++)deadEnemies[i].life=Math.min(deadEnemies[i].life,2);
    }

    // Wave banner timer (moved from draw to update for frame-rate independence)
    if(showWaveBanner&&waveBannerTimer>0){waveBannerTimer--;if(waveBannerTimer<=0)showWaveBanner=false}

    updatePlayer(player);updateBullets();updateEnemies();
    checkCollisions();updateParticles();updateScoreTokens();
    let puw=0;for(let i=0;i<powerUps.length;i++){const pu=powerUps[i];pu.y+=pu.vy;pu.pulse+=0.08;if(pu.y<GH+20)powerUps[puw++]=pu}powerUps.length=puw;
  }
}

function draw(){
  ctx.save();ctx.translate(shake.x,shake.y);
  ctx.fillStyle=C.bg;ctx.fillRect(-10,-10,GW+20,GH+20);
  ctx.textBaseline='middle'; // Consistent cross-browser text positioning

  if(state==='title'){drawTitle()}
  else if(state==='deploying'){drawDeploy()}
  else if(state==='map'){drawMap()}
  else{
    drawGrid();drawStars();
    drawDynamicBG(); // Full Context glow + big wave number
    if(state==='playing'||state==='gameover'||state==='paused'){
      drawDeadEnemies(); // Dissolving corpses (behind live enemies)
      for(let i=0;i<enemies.length;i++)drawEnemy(enemies[i]);
      if(boss&&boss.alive)drawBoss();
      if(player){drawPlayer(player);drawMuzzleFlash()}
      drawBullets();for(let i=0;i<powerUps.length;i++)drawPU(powerUps[i]);drawScoreTokens();drawParticles();
      drawPUFlash(); // Power-up pickup radial flash
      drawHUD();
      drawVignette(); // Low-health edge darkening
    }
    if(state==='playing'){
      drawGlitch();
      drawBossIntro();
    }
    if(state==='gameover')drawGameOver();
    if(state==='paused')drawPause();

    // Overclocked screen effect
    if(overclockedGlow>0.01){
      ctx.save();
      ctx.fillStyle=C.gold;ctx.globalAlpha=overclockedGlow*Math.abs(Math.sin(gt*0.08));
      ctx.fillRect(0,0,GW,GH);
      // Scan lines get more intense (optimized: fewer, larger lines)
      ctx.fillStyle='rgba(0,0,0,0.06)';
      for(let y=0;y<GH;y+=6){
        ctx.fillRect(0,y,GW,2);
      }
      ctx.restore();
    }

    if(nukeFlash>0){
      ctx.fillStyle='#FFF';ctx.globalAlpha=nukeFlash/15*0.4;
      ctx.fillRect(0,0,GW,GH);ctx.globalAlpha=1;
    }
    if(rageFlash>0){
      ctx.fillStyle='#FF2200';ctx.globalAlpha=rageFlash/12*0.35;
      ctx.fillRect(0,0,GW,GH);ctx.globalAlpha=1;
    }
  }
  ctx.restore();
}

let _lastFrameTime=0;
const _frameInterval=1000/62; // Cap at ~62fps (slight headroom above 60)
function loop(now){
  requestAnimationFrame(loop);
  if(!_lastFrameTime)_lastFrameTime=now;
  const elapsed=now-_lastFrameTime;
  if(elapsed<_frameInterval)return;
  _lastFrameTime=now-(elapsed%_frameInterval);
  update();draw();
}

// ═══════════════════════════════════════════════════════════════════════
// INPUT
// ═══════════════════════════════════════════════════════════════════════
const keysDown=new Set();
document.addEventListener('keydown',e=>{
  keysDown.add(e.code);
  if(e.code==='Enter'||e.code==='Space'){
    if(state==='title'){startGame();e.preventDefault();return}
    if(state==='gameover'){startGame();e.preventDefault();return}
    if(state==='paused'&&e.code==='Enter'){state='playing';startBGM();e.preventDefault();return}
  }
  if(state==='title'){
    if(e.code==='KeyA'||e.code==='ArrowLeft'){titleDiffIdx=Math.max(0,titleDiffIdx-1);e.preventDefault();return}
    if(e.code==='KeyD'||e.code==='ArrowRight'){titleDiffIdx=Math.min(2,titleDiffIdx+1);e.preventDefault();return}
  }
  if(e.code==='KeyP'&&(state==='playing'||state==='paused')){
    if(state==='paused'){state='playing';startBGM()}
    else{state='paused';stopBGM()}
    e.preventDefault();return;
  }
  if(e.code==='Escape'&&(state==='playing'||state==='paused')){
    if(state==='paused'){state='playing';startBGM()}
    else{state='paused';stopBGM()}
    e.preventDefault();return;
  }
  if(e.code==='KeyM'){
    sndOn=!sndOn;
    if(!sndOn)stopBGM();
    else if(state==='playing')startBGM();
    e.preventDefault();return;
  }
  if(state==='playing'&&player){
    if(e.code==='Space'){player.fire=true;e.preventDefault()}
    if(e.code==='KeyT'){doTaunt(player);e.preventDefault()}
  }
  // Shop selection
  if(shopActive&&shopChoices.length>0){
    if(e.code==='Digit1'||e.code==='Numpad1'){closeShop(0);e.preventDefault()}
    if(e.code==='Digit2'||e.code==='Numpad2'){closeShop(1);e.preventDefault()}
    if(e.code==='Digit3'||e.code==='Numpad3'){closeShop(2);e.preventDefault()}
  }
  // Map selection — number keys select reachable nodes in order
  if(state==='map'&&mapState==='choosing'&&mapGraph&&mapPlayerRow<6){
    for(let i=0;i<mapChoices.length;i++){
      const k=i+1;
      if(e.code==='Digit'+k||e.code==='Numpad'+k){selectMapPath(mapChoices[i]);e.preventDefault()}
    }
  }
  // Mystery choice — 1/2/3 keys
  if(state==='map'&&mapState==='mystery'&&mapMysteryChoices){
    for(let i=0;i<3;i++){
      const k=i+1;
      if(e.code==='Digit'+k||e.code==='Numpad'+k){selectMysteryChoice(i);e.preventDefault()}
    }
  }
  // Weapon lab choice — 1/2/3 keys
  if(state==='map'&&mapState==='weaponlab'&&mapWeaponLabChoices&&Array.isArray(mapWeaponLabChoices)){
    for(let i=0;i<mapWeaponLabChoices.length;i++){
      const k=i+1;
      if(e.code==='Digit'+k||e.code==='Numpad'+k){selectWeaponLabChoice(i);e.preventDefault()}
    }
  }
});
document.addEventListener('keyup',e=>{
  keysDown.delete(e.code);
  if(!player)return;
  if(e.code==='Space')player.fire=false;
});

let touchActive=false,lastTouchTime=0;
let touchOffsetX=0,touchOffsetY=0; // Offset between touch and player for relative tracking
function touchGameX(touch){const r=canvas.getBoundingClientRect();return(touch.clientX-r.left)/scale}
function touchGameY(touch){const r=canvas.getBoundingClientRect();return(touch.clientY-r.top)/scale}

canvas.addEventListener('touchstart',e=>{
  e.preventDefault();ensureAudio();
  if(state==='title'){
    const r=canvas.getBoundingClientRect();
    const tx=(e.touches[0].clientX-r.left)/scale;
    const ty=(e.touches[0].clientY-r.top)/scale;
    // Check if tapping in the difficulty selector area
    const diffAreaY=385; // Approximate Y of difficulty labels
    if(ty>diffAreaY-35&&ty<diffAreaY+35){
      if(tx<GW/3){titleDiffIdx=0;return}
      else if(tx>GW*2/3){titleDiffIdx=2;return}
      else{titleDiffIdx=1;return}
    }
    // Anywhere else starts the game
    startGame();return;
  }
  if(state==='gameover'){startGame();return}
  if(state==='playing'||state==='paused'){
    const r=canvas.getBoundingClientRect();
    const tx=(e.touches[0].clientX-r.left)/scale;
    const ty=(e.touches[0].clientY-r.top)/scale;
    if(tx>GW-52&&tx<GW-6&&ty>4&&ty<28){
      if(state==='paused'){state='playing';startBGM()}
      else{state='paused';stopBGM()}
      return;
    }
    if(state==='paused')return;
  }
  // Mystery touch selection — tap on choice cards
  if(state==='map'&&mapState==='mystery'&&mapMysteryChoices){
    const r=canvas.getBoundingClientRect();
    const tx=(e.touches[0].clientX-r.left)/scale;
    const ty=(e.touches[0].clientY-r.top)/scale;
    for(let i=0;i<3;i++){
      const cx=GW/2+(i-1)*140;
      if(tx>cx-52&&tx<cx+52&&ty>270&&ty<410){selectMysteryChoice(i);return}
    }
  }
  // Weapon lab touch selection
  if(state==='map'&&mapState==='weaponlab'&&mapWeaponLabChoices&&Array.isArray(mapWeaponLabChoices)){
    const r=canvas.getBoundingClientRect();
    const tx=(e.touches[0].clientX-r.left)/scale;
    const ty=(e.touches[0].clientY-r.top)/scale;
    for(let i=0;i<mapWeaponLabChoices.length;i++){
      const cx=GW/2+(i-1)*160;
      if(tx>cx-52&&tx<cx+52&&ty>270&&ty<410){selectWeaponLabChoice(i);return}
    }
  }
  // Map touch selection — tap on reachable nodes
  if(state==='map'&&mapState==='choosing'&&mapGraph&&mapPlayerRow<6){
    const r=canvas.getBoundingClientRect();
    const tx=(e.touches[0].clientX-r.left)/scale;
    const ty=(e.touches[0].clientY-r.top)/scale;
    const row=mapGraph.rows[mapPlayerRow];
    for(let n=0;n<row.nodes.length;n++){
      if(!row.nodes[n].reachable)continue;
      const pos=getMapNodeXY(mapPlayerRow,n);
      const dx=tx-pos.x,dy=ty-pos.y;
      if(dx*dx+dy*dy<900){selectMapPath(n);return}
    }
  }
  // Shop touch selection
  if(shopActive&&shopChoices.length>0){
    const r=canvas.getBoundingClientRect();
    const tx=(e.touches[0].clientX-r.left)/scale;
    const ty=(e.touches[0].clientY-r.top)/scale;
    if(ty>GH/2+76&&ty<GH/2+156){
      for(let i=0;i<3;i++){
        const sx=GW/2+(i-1)*120;
        if(tx>sx-50&&tx<sx+50){closeShop(i);return}
      }
    }
  }
  if(state==='playing'&&player){
    touchActive=true;player.fire=true;
    // Calculate offset between touch and player — ship tracks relative movement, not absolute position
    const txg=touchGameX(e.touches[0]),tyg=touchGameY(e.touches[0]);
    touchOffsetX=txg-player.x;touchOffsetY=tyg-player.y;
    player.tx=player.x;player.ty=player.y; // Start from current position
    // Mobile taunt: double-tap detection via quick successive touches
    const now=Date.now();
    if(now-lastTouchTime<300&&player.tauntCd<=0){doTaunt(player)}
    lastTouchTime=now;
  }
},{passive:false});

canvas.addEventListener('touchmove',e=>{
  e.preventDefault();
  if(state==='playing'&&player&&touchActive){
    player.tx=touchGameX(e.touches[0])-touchOffsetX;
    player.ty=touchGameY(e.touches[0])-touchOffsetY;
  }
},{passive:false});

canvas.addEventListener('touchend',e=>{
  e.preventDefault();
  if(e.touches.length===0){touchActive=false;if(player){player.tx=null;player.ty=null;player.fire=false}}
},{passive:false});

canvas.addEventListener('click',e=>{
  if(isMobile)return; // Touch events already handle mobile input
  ensureAudio();
  if(state==='title'){
    const r=canvas.getBoundingClientRect();
    const mx=(e.clientX-r.left)/scale;
    const my=(e.clientY-r.top)/scale;
    // Difficulty selector zone matches title screen diffY (265+120=385)
    if(my>350&&my<420){
      if(mx<GW/3){titleDiffIdx=0;return}
      else if(mx>GW*2/3){titleDiffIdx=2;return}
      else{titleDiffIdx=1;return}
    }
    startGame();
  }else if(shopActive&&shopChoices.length>0){
    const r=canvas.getBoundingClientRect();
    const mx=(e.clientX-r.left)/scale;
    const my=(e.clientY-r.top)/scale;
    if(my>GH/2+76&&my<GH/2+156){
      for(let i=0;i<3;i++){
        const sx=GW/2+(i-1)*120;
        if(mx>sx-50&&mx<sx+50){closeShop(i);return}
      }
    }
  }else if(state==='map'&&mapState==='mystery'&&mapMysteryChoices){
    const r=canvas.getBoundingClientRect();
    const mx=(e.clientX-r.left)/scale;
    const my=(e.clientY-r.top)/scale;
    for(let i=0;i<3;i++){
      const cx=GW/2+(i-1)*140;
      if(mx>cx-52&&mx<cx+52&&my>270&&my<410){selectMysteryChoice(i);return}
    }
  }else if(state==='map'&&mapState==='weaponlab'&&mapWeaponLabChoices&&Array.isArray(mapWeaponLabChoices)){
    const r=canvas.getBoundingClientRect();
    const mx=(e.clientX-r.left)/scale;
    const my=(e.clientY-r.top)/scale;
    for(let i=0;i<mapWeaponLabChoices.length;i++){
      const cx=GW/2+(i-1)*160;
      if(mx>cx-52&&mx<cx+52&&my>270&&my<410){selectWeaponLabChoice(i);return}
    }
  }else if(state==='map'&&mapState==='choosing'&&mapGraph&&mapPlayerRow<6){
    const r=canvas.getBoundingClientRect();
    const mx=(e.clientX-r.left)/scale;
    const my=(e.clientY-r.top)/scale;
    const row=mapGraph.rows[mapPlayerRow];
    for(let n=0;n<row.nodes.length;n++){
      if(!row.nodes[n].reachable)continue;
      const pos=getMapNodeXY(mapPlayerRow,n);
      const dx=mx-pos.x,dy=my-pos.y;
      if(dx*dx+dy*dy<900){selectMapPath(n);return}
    }
  }else if(state==='gameover')startGame();
});

canvas.addEventListener('mousemove',e=>{
  const r=canvas.getBoundingClientRect();
  const mx=(e.clientX-r.left)/scale;
  const my=(e.clientY-r.top)/scale;
  if(state==='map'&&mapState==='choosing'&&mapGraph&&mapPlayerRow<6){
    mapHoverNode=-1;
    const row=mapGraph.rows[mapPlayerRow];
    for(let n=0;n<row.nodes.length;n++){
      if(!row.nodes[n].reachable)continue;
      const pos=getMapNodeXY(mapPlayerRow,n);
      const dx=mx-pos.x,dy=my-pos.y;
      if(dx*dx+dy*dy<900){mapHoverNode=n;break}
    }
  }
  if(state==='map'&&mapState==='mystery'&&mapMysteryChoices){
    mapMysteryHover=-1;
    for(let i=0;i<3;i++){
      const cx=GW/2+(i-1)*140;
      if(mx>cx-52&&mx<cx+52&&my>270&&my<410){mapMysteryHover=i;break}
    }
  }
  if(state==='map'&&mapState==='weaponlab'&&mapWeaponLabChoices&&Array.isArray(mapWeaponLabChoices)){
    mapMysteryHover=-1;
    for(let i=0;i<mapWeaponLabChoices.length;i++){
      const cx=GW/2+(i-1)*160;
      if(mx>cx-52&&mx<cx+52&&my>270&&my<410){mapMysteryHover=i;break}
    }
  }
  // Shop hover detection
  if(shopActive&&shopChoices.length>0){
    shopSelected=-1;
    if(my>GH/2+76&&my<GH/2+156){
      for(let i=0;i<3;i++){
        const sx=GW/2+(i-1)*120;
        if(mx>sx-50&&mx<sx+50){shopSelected=i;break}
      }
    }
  }
});

// ═══════════════════════════════════════════════════════════════════════
// VISIBILITY — auto-pause when tab loses focus
// ═══════════════════════════════════════════════════════════════════════
document.addEventListener('visibilitychange',()=>{
  if(document.hidden&&state==='playing'){state='paused';stopBGM();keysDown.clear()}
});
window.addEventListener('blur',()=>{
  if(state==='playing'){state='paused';stopBGM()}
  keysDown.clear(); // Prevent stuck keys after alt-tab
});

// ═══════════════════════════════════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════════════════════════════════
initStars();requestAnimationFrame(loop);
</script>
</body>
</html>
